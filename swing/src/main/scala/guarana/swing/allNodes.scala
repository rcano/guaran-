//AUTOGENERATED FILE, DO NOT MODIFY

package guarana.swing
import language.implicitConversions
import java.awt.{Component => _, TextComponent => _, _}
import java.awt.event._
import javax.swing._
import javax.swing.event._
import guarana.swing.util._
import scala.jdk.CollectionConverters._
import scala.util.chaining._

opaque type Node  = java.awt.Container
object Node extends VarsMap {
  val Background: SwingVar.Aux[Node, java.awt.Color | Null] = SwingVar[Node, java.awt.Color | Null]("background", _.getBackground, _.setBackground(_))
  val Bounds: SwingVar.Aux[Node, Bounds] = SwingVar[Node, Bounds]("bounds", _.getBounds.nn, _.setBounds(_))
  val ComponentOrientation: SwingVar.Aux[Node, java.awt.ComponentOrientation] = SwingVar[Node, java.awt.ComponentOrientation]("componentOrientation", _.getComponentOrientation.nn, _.setComponentOrientation(_))
  val Cursor: SwingVar.Aux[Node, java.awt.Cursor | Null] = SwingVar[Node, java.awt.Cursor | Null]("cursor", _.getCursor, _.setCursor(_))
  val Enabled: SwingVar.Aux[Node, Boolean] = SwingVar[Node, Boolean]("enabled", _.isEnabled, _.setEnabled(_))
  val Focusable: SwingVar.Aux[Node, Boolean] = SwingVar[Node, Boolean]("focusable", _.isFocusable, _.setFocusable(_))
  private val FocusedMut: Var[Boolean] = Var[Boolean]("focusedMut", false)
  val Font: SwingVar.Aux[Node, java.awt.Font | Null] = SwingVar[Node, java.awt.Font | Null]("font", _.getFont, _.setFont(_))
  val Foreground: SwingVar.Aux[Node, java.awt.Color | Null] = SwingVar[Node, java.awt.Color | Null]("foreground", _.getForeground, _.setForeground(_))
  val MaxSize: SwingVar.Aux[Node, (Double, Double) | Null] = SwingVar[Node, (Double, Double) | Null]("maxSize", {n => val d = n.getMaximumSize; if (d != null) (d.getWidth, d.getHeight) else null}, {(n, d) => n.setMaximumSize(if (d == null) null else java.awt.Dimension(d._1.toInt, d._2.toInt))})
  val MinSize: SwingVar.Aux[Node, (Double, Double) | Null] = SwingVar[Node, (Double, Double) | Null]("minSize", {n => val d = n.getMinimumSize; if (d != null) (d.getWidth, d.getHeight) else null}, {(n, d) => n.setMinimumSize(if (d == null) null else java.awt.Dimension(d._1.toInt, d._2.toInt))})
  private val MouseLocationMut: Var[(Int, Int)] = Var[(Int, Int)]("mouseLocationMut", (0, 0))
  val PrefSize: SwingVar.Aux[Node, (Double, Double) | Null] = SwingVar[Node, (Double, Double) | Null]("prefSize", {n => val d = n.getPreferredSize; if (d != null) (d.getWidth, d.getHeight) else null}, {(n, d) => n.setPreferredSize(if (d == null) null else java.awt.Dimension(d._1.toInt, d._2.toInt))})
  val Visible: SwingVar.Aux[Node, Boolean] = SwingVar[Node, Boolean]("visible", _.isVisible, _.setVisible(_))

  val FocusEvents = Emitter[(FocusEvent, Boolean)]()

  extension ops on (v: Node) {
    def background: Var.Aux[java.awt.Color | Null, v.type] = Node.Background.forInstance(v)
    def bounds: Var.Aux[Bounds, v.type] = Node.Bounds.forInstance(v)
    def componentOrientation: Var.Aux[java.awt.ComponentOrientation, v.type] = Node.ComponentOrientation.forInstance(v)
    def cursor: Var.Aux[java.awt.Cursor | Null, v.type] = Node.Cursor.forInstance(v)
    def enabled: Var.Aux[Boolean, v.type] = Node.Enabled.forInstance(v)
    def focusable: Var.Aux[Boolean, v.type] = Node.Focusable.forInstance(v)
    def focusedMut: Var.Aux[Boolean, v.type] = Node.FocusedMut.forInstance(v)
    def font: Var.Aux[java.awt.Font | Null, v.type] = Node.Font.forInstance(v)
    def foreground: Var.Aux[java.awt.Color | Null, v.type] = Node.Foreground.forInstance(v)
    def maxSize: Var.Aux[(Double, Double) | Null, v.type] = Node.MaxSize.forInstance(v)
    def minSize: Var.Aux[(Double, Double) | Null, v.type] = Node.MinSize.forInstance(v)
    def mouseLocationMut: Var.Aux[(Int, Int), v.type] = Node.MouseLocationMut.forInstance(v)
    def prefSize: Var.Aux[(Double, Double) | Null, v.type] = Node.PrefSize.forInstance(v)
    def visible: Var.Aux[Boolean, v.type] = Node.Visible.forInstance(v)

    def focusEvents: Emitter.Aux[(FocusEvent, Boolean), v.type] = Node.FocusEvents.forInstance(v)

    def focused = Node.FocusedMut.asObsValIn(v)
    def mouseLocation = Node.MouseLocationMut.asObsValIn(v)
    def alignmentX = v.getAlignmentX
    def alignmentY = v.getAlignmentY
    def insets = v.getInsets
    def location = v.getLocation
    def size = v.getSize
    def location(x: Int, y: Int) = v.setLocation(x, y)
    def requestFocus() = v.requestFocus()
    def requestFocusInWindow() = v.requestFocusInWindow()
    def size(x: Int, y: Int) = v.setSize(x, y)
    def children: Seq[Node] = (0 until v.getComponentCount).map(i => v.getComponent(i).asInstanceOf[Container])
    def unwrap: java.awt.Container = v
  }

  def apply(v: java.awt.Container) = v.asInstanceOf[Node]

  def init(v: Node): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    
    sc.update {
      val ctx = summon[Emitter.Context]
      ctx.register(v.focusEvents)
    }
    v.addPropertyChangeListener(varsPropertyListener(v))
    v addMouseMotionListener new java.awt.event.MouseMotionListener {
      def mouseDragged(evt: java.awt.event.MouseEvent | Null) = ()
      def mouseMoved(evt: java.awt.event.MouseEvent | Null) = sc.update {
        val nnEvt = evt.nn
        Node.MouseLocationMut.forInstance(v) := (nnEvt.getX, nnEvt.getY)
      }
    }
    v addFocusListener new FocusListener {
      def focusGained(evt: FocusEvent | UncheckedNull) = sc.update {
        Node.FocusedMut.forInstance(v) := true 
        summon[Emitter.Context].emit(v.focusEvents, (evt.nn -> true))
      }
      def focusLost(evt: FocusEvent | UncheckedNull) = sc.update {
        Node.FocusedMut.forInstance(v) := false
        summon[Emitter.Context].emit(v.focusEvents, (evt.nn -> false))
      }
    }
    
  }
  def uninitialized(): Node = {
    val res = java.awt.Container().asInstanceOf[Node]
    
    res
  }
  
  def apply(
    
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Node] = {
    val res = uninitialized()
    Node.init(res)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Component <: Node = javax.swing.JComponent & Node
object Component extends VarsMap {
  val ActionMap: SwingVar.Aux[Component, javax.swing.ActionMap] = SwingVar[Component, javax.swing.ActionMap]("actionMap", _.getActionMap.nn, _.setActionMap(_))
  val AlignmentX: SwingVar.Aux[Component, Float] = SwingVar[Component, Float]("alignmentX", _.getAlignmentX, _.setAlignmentX(_))
  val AlignmentY: SwingVar.Aux[Component, Float] = SwingVar[Component, Float]("alignmentY", _.getAlignmentY, _.setAlignmentY(_))
  val Autoscrolls: SwingVar.Aux[Component, Boolean] = SwingVar[Component, Boolean]("autoscrolls", _.getAutoscrolls, _.setAutoscrolls(_))
  val Border: SwingVar.Aux[Component, javax.swing.border.Border | Null] = SwingVar[Component, javax.swing.border.Border | Null]("border", _.getBorder, _.setBorder(_))
  val ComponentPopupMenu: SwingVar.Aux[Component, javax.swing.JPopupMenu | Null] = SwingVar[Component, javax.swing.JPopupMenu | Null]("componentPopupMenu", _.getComponentPopupMenu, _.setComponentPopupMenu(_))
  val DebugGraphicsOptions: SwingVar.Aux[Component, Int] = SwingVar[Component, Int]("debugGraphicsOptions", _.getDebugGraphicsOptions, _.setDebugGraphicsOptions(_))
  val DoubleBuffered: SwingVar.Aux[Component, Boolean] = SwingVar[Component, Boolean]("doubleBuffered", _.isDoubleBuffered, _.setDoubleBuffered(_))
  val InheritsPopupMenu: SwingVar.Aux[Component, Boolean] = SwingVar[Component, Boolean]("inheritsPopupMenu", _.getInheritsPopupMenu, _.setInheritsPopupMenu(_))
  val InputVerifier: SwingVar.Aux[Component, javax.swing.InputVerifier | Null] = SwingVar[Component, javax.swing.InputVerifier | Null]("inputVerifier", _.getInputVerifier, _.setInputVerifier(_))
  val Opaque: SwingVar.Aux[Component, Boolean] = SwingVar[Component, Boolean]("opaque", _.isOpaque, _.setOpaque(_))
  val RequestFocusEnabled: SwingVar.Aux[Component, Boolean] = SwingVar[Component, Boolean]("requestFocusEnabled", _.isRequestFocusEnabled, _.setRequestFocusEnabled(_))
  val ToolTipText: SwingVar.Aux[Component, String | Null] = SwingVar[Component, String | Null]("toolTipText", _.getToolTipText, _.setToolTipText(_))
  val TransferHandler: SwingVar.Aux[Component, javax.swing.TransferHandler | Null] = SwingVar[Component, javax.swing.TransferHandler | Null]("transferHandler", _.getTransferHandler, _.setTransferHandler(_))
  val VerifyInputWhenFocusTarget: SwingVar.Aux[Component, Boolean] = SwingVar[Component, Boolean]("verifyInputWhenFocusTarget", _.getVerifyInputWhenFocusTarget, _.setVerifyInputWhenFocusTarget(_))

  

  extension ops on (v: Component) {
    def actionMap: Var.Aux[javax.swing.ActionMap, v.type] = Component.ActionMap.forInstance(v)
    def alignmentX: Var.Aux[Float, v.type] = Component.AlignmentX.forInstance(v)
    def alignmentY: Var.Aux[Float, v.type] = Component.AlignmentY.forInstance(v)
    def autoscrolls: Var.Aux[Boolean, v.type] = Component.Autoscrolls.forInstance(v)
    def border: Var.Aux[javax.swing.border.Border | Null, v.type] = Component.Border.forInstance(v)
    def componentPopupMenu: Var.Aux[javax.swing.JPopupMenu | Null, v.type] = Component.ComponentPopupMenu.forInstance(v)
    def debugGraphicsOptions: Var.Aux[Int, v.type] = Component.DebugGraphicsOptions.forInstance(v)
    def doubleBuffered: Var.Aux[Boolean, v.type] = Component.DoubleBuffered.forInstance(v)
    def inheritsPopupMenu: Var.Aux[Boolean, v.type] = Component.InheritsPopupMenu.forInstance(v)
    def inputVerifier: Var.Aux[javax.swing.InputVerifier | Null, v.type] = Component.InputVerifier.forInstance(v)
    def opaque: Var.Aux[Boolean, v.type] = Component.Opaque.forInstance(v)
    def requestFocusEnabled: Var.Aux[Boolean, v.type] = Component.RequestFocusEnabled.forInstance(v)
    def toolTipText: Var.Aux[String | Null, v.type] = Component.ToolTipText.forInstance(v)
    def transferHandler: Var.Aux[javax.swing.TransferHandler | Null, v.type] = Component.TransferHandler.forInstance(v)
    def verifyInputWhenFocusTarget: Var.Aux[Boolean, v.type] = Component.VerifyInputWhenFocusTarget.forInstance(v)

    

    def UI = v.getUI
    def UIClassID = v.getUIClassID
    def ancestorListeners = v.getAncestorListeners
    def inputMap = v.getInputMap
    def optimizedDrawingEnabled = v.isOptimizedDrawingEnabled
    def paintingForPrint = v.isPaintingForPrint
    def paintingTile = v.isPaintingTile
    def registeredKeyStrokes = v.getRegisteredKeyStrokes
    def rootPane = v.getRootPane
    def topLevelAncestor = v.getTopLevelAncestor
    def vetoableChangeListeners = v.getVetoableChangeListeners
    def visibleRect = v.getVisibleRect
    def unwrap: javax.swing.JComponent = v
  }

  def apply(v: javax.swing.JComponent) = v.asInstanceOf[Component]

  def init(v: Component): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Node.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  
}

opaque type WindowBase <: Node = java.awt.Window & Node
object WindowBase extends VarsMap {
  val AlwaysOnTop: SwingVar.Aux[WindowBase, Boolean] = SwingVar[WindowBase, Boolean]("alwaysOnTop", _.isAlwaysOnTop, _.setAlwaysOnTop(_))
  val AutoRequestFocus: SwingVar.Aux[WindowBase, Boolean] = SwingVar[WindowBase, Boolean]("autoRequestFocus", _.isAutoRequestFocus, _.setAutoRequestFocus(_))
  val FocusCycleRoot: SwingVar.Aux[WindowBase, Boolean] = SwingVar[WindowBase, Boolean]("focusCycleRoot", _.isFocusCycleRoot, _.setFocusCycleRoot(_))
  val FocusableWindowState: SwingVar.Aux[WindowBase, Boolean] = SwingVar[WindowBase, Boolean]("focusableWindowState", _.getFocusableWindowState, _.setFocusableWindowState(_))
  val IconImages: SwingVar.Aux[WindowBase, java.util.List[_ <: java.awt.Image] | Null] = SwingVar[WindowBase, java.util.List[_ <: java.awt.Image] | Null]("iconImages", _.getIconImages, _.setIconImages(_))
  val LocationByPlatform: SwingVar.Aux[WindowBase, Boolean] = SwingVar[WindowBase, Boolean]("locationByPlatform", _.isLocationByPlatform, _.setLocationByPlatform(_))
  val ModalExclusionType: SwingVar.Aux[WindowBase, java.awt.Dialog.ModalExclusionType] = SwingVar[WindowBase, java.awt.Dialog.ModalExclusionType]("modalExclusionType", _.getModalExclusionType.nn, _.setModalExclusionType(_))
  val Opacity: SwingVar.Aux[WindowBase, Float] = SwingVar[WindowBase, Float]("opacity", _.getOpacity, _.setOpacity(_))
  val Root: SwingVar.Aux[WindowBase, Node] = SwingVar[WindowBase, Node]("root", c => Node(c.getComponent(0).asInstanceOf[Container]), (w, n) => w.add(n, 0))
  val Shape: SwingVar.Aux[WindowBase, java.awt.Shape | Null] = SwingVar[WindowBase, java.awt.Shape | Null]("shape", _.getShape, _.setShape(_))
  val Tpe: SwingVar.Aux[WindowBase, java.awt.Window.Type] = SwingVar[WindowBase, java.awt.Window.Type]("tpe", _.getType.nn, _.setType(_))

  

  extension ops on (v: WindowBase) {
    def alwaysOnTop: Var.Aux[Boolean, v.type] = WindowBase.AlwaysOnTop.forInstance(v)
    def autoRequestFocus: Var.Aux[Boolean, v.type] = WindowBase.AutoRequestFocus.forInstance(v)
    def focusCycleRoot: Var.Aux[Boolean, v.type] = WindowBase.FocusCycleRoot.forInstance(v)
    def focusableWindowState: Var.Aux[Boolean, v.type] = WindowBase.FocusableWindowState.forInstance(v)
    def iconImages: Var.Aux[java.util.List[_ <: java.awt.Image] | Null, v.type] = WindowBase.IconImages.forInstance(v)
    def locationByPlatform: Var.Aux[Boolean, v.type] = WindowBase.LocationByPlatform.forInstance(v)
    def modalExclusionType: Var.Aux[java.awt.Dialog.ModalExclusionType, v.type] = WindowBase.ModalExclusionType.forInstance(v)
    def opacity: Var.Aux[Float, v.type] = WindowBase.Opacity.forInstance(v)
    def root: Var.Aux[Node, v.type] = WindowBase.Root.forInstance(v)
    def shape: Var.Aux[java.awt.Shape | Null, v.type] = WindowBase.Shape.forInstance(v)
    def tpe: Var.Aux[java.awt.Window.Type, v.type] = WindowBase.Tpe.forInstance(v)

    

    def accessibleContext = v.getAccessibleContext
    def active = v.isActive
    def alwaysOnTopSupported = v.isAlwaysOnTopSupported
    def bufferStrategy = v.getBufferStrategy
    def focusCycleRootAncestor = v.getFocusCycleRootAncestor
    def focusOwner = v.getFocusOwner
    def focusableWindow = v.isFocusableWindow
    def focused = v.isFocused
    def inputContext = v.getInputContext
    def locale = v.getLocale
    def mostRecentFocusOwner = v.getMostRecentFocusOwner
    def opaque = v.isOpaque
    def ownedWindows = v.getOwnedWindows
    def owner = v.getOwner
    def pack() = v.pack()
    def showing = v.isShowing
    def toFront() = v.toFront()
    def toBack() = v.toBack()
    def toolkit = v.getToolkit
    def validateRoot = v.isValidateRoot
    def warningString = v.getWarningString
    def windowFocusListeners = v.getWindowFocusListeners
    def windowListeners = v.getWindowListeners
    def windowStateListeners = v.getWindowStateListeners
    def unwrap: java.awt.Window = v
  }

  def apply(v: java.awt.Window) = v.asInstanceOf[WindowBase]

  def init(v: WindowBase): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Node.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(parent: java.awt.Window | Null = null, gc: GraphicsConfiguration | Null = null): WindowBase = {
    val res = java.awt.Window(parent, gc).asInstanceOf[WindowBase]
    
    res
  }
  
  def apply(
    parent: java.awt.Window | Null = null, gc: GraphicsConfiguration | Null = null,
    alwaysOnTop: Opt[Binding[Boolean]] = UnsetParam,
    autoRequestFocus: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusCycleRoot: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusableWindowState: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    iconImages: Opt[Binding[java.util.List[_ <: java.awt.Image] | Null]] = UnsetParam,
    locationByPlatform: Opt[Binding[Boolean]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    modalExclusionType: Opt[Binding[java.awt.Dialog.ModalExclusionType]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opacity: Opt[Binding[Float]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    root: Opt[Binding[Node]] = UnsetParam,
    shape: Opt[Binding[java.awt.Shape | Null]] = UnsetParam,
    tpe: Opt[Binding[java.awt.Window.Type]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[WindowBase] = {
    val res = uninitialized()
    WindowBase.init(res)
    ifSet(alwaysOnTop, WindowBase.ops.alwaysOnTop(res) := _)
    ifSet(autoRequestFocus, WindowBase.ops.autoRequestFocus(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusCycleRoot, WindowBase.ops.focusCycleRoot(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusableWindowState, WindowBase.ops.focusableWindowState(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(iconImages, WindowBase.ops.iconImages(res) := _)
    ifSet(locationByPlatform, WindowBase.ops.locationByPlatform(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(modalExclusionType, WindowBase.ops.modalExclusionType(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opacity, WindowBase.ops.opacity(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(root, WindowBase.ops.root(res) := _)
    ifSet(shape, WindowBase.ops.shape(res) := _)
    ifSet(tpe, WindowBase.ops.tpe(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Window <: WindowBase = javax.swing.JWindow & WindowBase
object Window extends VarsMap {
  val ContentPane: SwingVar.Aux[Window, java.awt.Container] = SwingVar[Window, java.awt.Container]("contentPane", _.getContentPane().nn, _.setContentPane(_))
  val GlassPane: SwingVar.Aux[Window, java.awt.Component | Null] = SwingVar[Window, java.awt.Component | Null]("glassPane", _.getGlassPane, _.setGlassPane(_))
  val LayeredPane: SwingVar.Aux[Window, javax.swing.JLayeredPane | Null] = SwingVar[Window, javax.swing.JLayeredPane | Null]("layeredPane", _.getLayeredPane, _.setLayeredPane(_))
  val TransferHandler: SwingVar.Aux[Window, javax.swing.TransferHandler | Null] = SwingVar[Window, javax.swing.TransferHandler | Null]("transferHandler", _.getTransferHandler, _.setTransferHandler(_))

  

  extension ops on (v: Window) {
    def contentPane: Var.Aux[java.awt.Container, v.type] = Window.ContentPane.forInstance(v)
    def glassPane: Var.Aux[java.awt.Component | Null, v.type] = Window.GlassPane.forInstance(v)
    def layeredPane: Var.Aux[javax.swing.JLayeredPane | Null, v.type] = Window.LayeredPane.forInstance(v)
    def transferHandler: Var.Aux[javax.swing.TransferHandler | Null, v.type] = Window.TransferHandler.forInstance(v)

    

    def rootPane: JRootPane = v.getRootPane.nn
    def unwrap: javax.swing.JWindow = v
  }

  def apply(v: javax.swing.JWindow) = v.asInstanceOf[Window]

  def init(v: Window): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    WindowBase.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(gc: GraphicsConfiguration | Null = null): Window = {
    val res = javax.swing.JWindow(gc).asInstanceOf[Window]
    
    res
  }
  
  def apply(
    gc: GraphicsConfiguration | Null = null,
    alwaysOnTop: Opt[Binding[Boolean]] = UnsetParam,
    autoRequestFocus: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    contentPane: Opt[Binding[java.awt.Container]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusCycleRoot: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusableWindowState: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    glassPane: Opt[Binding[java.awt.Component | Null]] = UnsetParam,
    iconImages: Opt[Binding[java.util.List[_ <: java.awt.Image] | Null]] = UnsetParam,
    layeredPane: Opt[Binding[javax.swing.JLayeredPane | Null]] = UnsetParam,
    locationByPlatform: Opt[Binding[Boolean]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    modalExclusionType: Opt[Binding[java.awt.Dialog.ModalExclusionType]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opacity: Opt[Binding[Float]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    root: Opt[Binding[Node]] = UnsetParam,
    shape: Opt[Binding[java.awt.Shape | Null]] = UnsetParam,
    tpe: Opt[Binding[java.awt.Window.Type]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Window] = {
    val res = uninitialized()
    Window.init(res)
    ifSet(alwaysOnTop, WindowBase.ops.alwaysOnTop(res) := _)
    ifSet(autoRequestFocus, WindowBase.ops.autoRequestFocus(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(contentPane, Window.ops.contentPane(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusCycleRoot, WindowBase.ops.focusCycleRoot(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusableWindowState, WindowBase.ops.focusableWindowState(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(glassPane, Window.ops.glassPane(res) := _)
    ifSet(iconImages, WindowBase.ops.iconImages(res) := _)
    ifSet(layeredPane, Window.ops.layeredPane(res) := _)
    ifSet(locationByPlatform, WindowBase.ops.locationByPlatform(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(modalExclusionType, WindowBase.ops.modalExclusionType(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opacity, WindowBase.ops.opacity(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(root, WindowBase.ops.root(res) := _)
    ifSet(shape, WindowBase.ops.shape(res) := _)
    ifSet(tpe, WindowBase.ops.tpe(res) := _)
    ifSet(transferHandler, Window.ops.transferHandler(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Frame <: WindowBase = javax.swing.JFrame & WindowBase
object Frame extends VarsMap {
  val ContentPane: SwingVar.Aux[Frame, java.awt.Container] = SwingVar[Frame, java.awt.Container]("contentPane", _.getContentPane().nn, _.setContentPane(_))
  val DefaultCloseOperation: SwingVar.Aux[Frame, Int] = SwingVar[Frame, Int]("defaultCloseOperation", _.getDefaultCloseOperation, _.setDefaultCloseOperation(_))
  val ExtendedState: SwingVar.Aux[Frame, Int] = SwingVar[Frame, Int]("extendedState", _.getExtendedState, _.setExtendedState(_))
  val GlassPane: SwingVar.Aux[Frame, java.awt.Component | Null] = SwingVar[Frame, java.awt.Component | Null]("glassPane", _.getGlassPane, _.setGlassPane(_))
  val IconImage: SwingVar.Aux[Frame, java.awt.Image | Null] = SwingVar[Frame, java.awt.Image | Null]("iconImage", _.getIconImage, _.setIconImage(_))
  val LayeredPane: SwingVar.Aux[Frame, javax.swing.JLayeredPane | Null] = SwingVar[Frame, javax.swing.JLayeredPane | Null]("layeredPane", _.getLayeredPane, _.setLayeredPane(_))
  val MaximizedBounds: SwingVar.Aux[Frame, Bounds | Null] = SwingVar[Frame, Bounds | Null]("maximizedBounds", _.getMaximizedBounds, _.setMaximizedBounds(_))
  val MenuBar: SwingVar.Aux[Frame, javax.swing.JMenuBar | Null] = SwingVar[Frame, javax.swing.JMenuBar | Null]("menuBar", _.getJMenuBar, _.setJMenuBar(_))
  val Resizable: SwingVar.Aux[Frame, Boolean] = SwingVar[Frame, Boolean]("resizable", _.isResizable, _.setResizable(_))
  val State: SwingVar.Aux[Frame, Int] = SwingVar[Frame, Int]("state", _.getState, _.setState(_))
  val Title: SwingVar.Aux[Frame, java.lang.String | Null] = SwingVar[Frame, java.lang.String | Null]("title", _.getTitle, _.setTitle(_))
  val TransferHandler: SwingVar.Aux[Frame, javax.swing.TransferHandler | Null] = SwingVar[Frame, javax.swing.TransferHandler | Null]("transferHandler", _.getTransferHandler, _.setTransferHandler(_))
  val Undecorated: SwingVar.Aux[Frame, Boolean] = SwingVar[Frame, Boolean]("undecorated", _.isUndecorated, _.setUndecorated(_))

  

  extension ops on (v: Frame) {
    def contentPane: Var.Aux[java.awt.Container, v.type] = Frame.ContentPane.forInstance(v)
    def defaultCloseOperation: Var.Aux[Int, v.type] = Frame.DefaultCloseOperation.forInstance(v)
    def extendedState: Var.Aux[Int, v.type] = Frame.ExtendedState.forInstance(v)
    def glassPane: Var.Aux[java.awt.Component | Null, v.type] = Frame.GlassPane.forInstance(v)
    def iconImage: Var.Aux[java.awt.Image | Null, v.type] = Frame.IconImage.forInstance(v)
    def layeredPane: Var.Aux[javax.swing.JLayeredPane | Null, v.type] = Frame.LayeredPane.forInstance(v)
    def maximizedBounds: Var.Aux[Bounds | Null, v.type] = Frame.MaximizedBounds.forInstance(v)
    def menuBar: Var.Aux[javax.swing.JMenuBar | Null, v.type] = Frame.MenuBar.forInstance(v)
    def resizable: Var.Aux[Boolean, v.type] = Frame.Resizable.forInstance(v)
    def state: Var.Aux[Int, v.type] = Frame.State.forInstance(v)
    def title: Var.Aux[java.lang.String | Null, v.type] = Frame.Title.forInstance(v)
    def transferHandler: Var.Aux[javax.swing.TransferHandler | Null, v.type] = Frame.TransferHandler.forInstance(v)
    def undecorated: Var.Aux[Boolean, v.type] = Frame.Undecorated.forInstance(v)

    

    def rootPane: JRootPane = v.getRootPane.nn
    def unwrap: javax.swing.JFrame = v
  }

  def apply(v: javax.swing.JFrame) = v.asInstanceOf[Frame]

  def init(v: Frame): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    WindowBase.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(gc: GraphicsConfiguration | Null = null): Frame = {
    val res = javax.swing.JFrame(gc).asInstanceOf[Frame]
    
    res
  }
  
  def apply(
    gc: GraphicsConfiguration | Null = null,
    alwaysOnTop: Opt[Binding[Boolean]] = UnsetParam,
    autoRequestFocus: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    contentPane: Opt[Binding[java.awt.Container]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    defaultCloseOperation: Opt[Binding[Int]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    extendedState: Opt[Binding[Int]] = UnsetParam,
    focusCycleRoot: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusableWindowState: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    glassPane: Opt[Binding[java.awt.Component | Null]] = UnsetParam,
    iconImage: Opt[Binding[java.awt.Image | Null]] = UnsetParam,
    iconImages: Opt[Binding[java.util.List[_ <: java.awt.Image] | Null]] = UnsetParam,
    layeredPane: Opt[Binding[javax.swing.JLayeredPane | Null]] = UnsetParam,
    locationByPlatform: Opt[Binding[Boolean]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    maximizedBounds: Opt[Binding[Bounds | Null]] = UnsetParam,
    menuBar: Opt[Binding[javax.swing.JMenuBar | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    modalExclusionType: Opt[Binding[java.awt.Dialog.ModalExclusionType]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opacity: Opt[Binding[Float]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    resizable: Opt[Binding[Boolean]] = UnsetParam,
    root: Opt[Binding[Node]] = UnsetParam,
    shape: Opt[Binding[java.awt.Shape | Null]] = UnsetParam,
    state: Opt[Binding[Int]] = UnsetParam,
    title: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    tpe: Opt[Binding[java.awt.Window.Type]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    undecorated: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Frame] = {
    val res = uninitialized()
    Frame.init(res)
    ifSet(alwaysOnTop, WindowBase.ops.alwaysOnTop(res) := _)
    ifSet(autoRequestFocus, WindowBase.ops.autoRequestFocus(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(contentPane, Frame.ops.contentPane(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(defaultCloseOperation, Frame.ops.defaultCloseOperation(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(extendedState, Frame.ops.extendedState(res) := _)
    ifSet(focusCycleRoot, WindowBase.ops.focusCycleRoot(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusableWindowState, WindowBase.ops.focusableWindowState(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(glassPane, Frame.ops.glassPane(res) := _)
    ifSet(iconImage, Frame.ops.iconImage(res) := _)
    ifSet(iconImages, WindowBase.ops.iconImages(res) := _)
    ifSet(layeredPane, Frame.ops.layeredPane(res) := _)
    ifSet(locationByPlatform, WindowBase.ops.locationByPlatform(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(maximizedBounds, Frame.ops.maximizedBounds(res) := _)
    ifSet(menuBar, Frame.ops.menuBar(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(modalExclusionType, WindowBase.ops.modalExclusionType(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opacity, WindowBase.ops.opacity(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(resizable, Frame.ops.resizable(res) := _)
    ifSet(root, WindowBase.ops.root(res) := _)
    ifSet(shape, WindowBase.ops.shape(res) := _)
    ifSet(state, Frame.ops.state(res) := _)
    ifSet(title, Frame.ops.title(res) := _)
    ifSet(tpe, WindowBase.ops.tpe(res) := _)
    ifSet(transferHandler, Frame.ops.transferHandler(res) := _)
    ifSet(undecorated, Frame.ops.undecorated(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Pane <: Component = javax.swing.JPanel & Component
object Pane extends VarsMap {
  val UI: SwingVar.Aux[Pane, javax.swing.plaf.PanelUI] = SwingVar[Pane, javax.swing.plaf.PanelUI]("UI", _.getUI.nn, _.setUI(_))

  

  extension ops on (v: Pane) {
    def UI: Var.Aux[javax.swing.plaf.PanelUI, v.type] = Pane.UI.forInstance(v)

    

    
    def unwrap: javax.swing.JPanel = v
  }

  def apply(v: javax.swing.JPanel) = v.asInstanceOf[Pane]

  def init(v: Pane): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): Pane = {
    val res = javax.swing.JPanel().asInstanceOf[Pane]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.PanelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Pane] = {
    val res = uninitialized()
    Pane.init(res)
    ifSet(UI, Pane.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type AbsolutePositioningPane <: Pane = javax.swing.JPanel & Pane
object AbsolutePositioningPane extends VarsMap {
  val Nodes: SwingVar.Aux[AbsolutePositioningPane, Seq[Node]] = SwingVar[AbsolutePositioningPane, Seq[Node]]("nodes", c => (0 until c.getComponentCount).map(c.getComponent(_).asInstanceOf[Node]), (p, children) => { p.removeAll(); children foreach (n => p.add(n)) })

  

  extension ops on (v: AbsolutePositioningPane) {
    def nodes: Var.Aux[Seq[Node], v.type] = AbsolutePositioningPane.Nodes.forInstance(v)

    

    
    def unwrap: javax.swing.JPanel = v
  }

  def apply(v: javax.swing.JPanel) = v.asInstanceOf[AbsolutePositioningPane]

  def init(v: AbsolutePositioningPane): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Pane.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): AbsolutePositioningPane = {
    val res = javax.swing.JPanel().asInstanceOf[AbsolutePositioningPane]
    res.asInstanceOf[JPanel].setLayout(null)
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.PanelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    nodes: Opt[Binding[Seq[Node]]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[AbsolutePositioningPane] = {
    val res = uninitialized()
    AbsolutePositioningPane.init(res)
    ifSet(UI, Pane.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(nodes, AbsolutePositioningPane.ops.nodes(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type BorderPane <: Pane = javax.swing.JPanel & Pane
object BorderPane extends VarsMap {
  val Bottom: SwingVar.Aux[BorderPane, Node | Null] = SwingVar[BorderPane, Node | Null]("bottom", c => c.getLayout.asInstanceOf[BorderLayout].getLayoutComponent(BorderLayout.SOUTH).asInstanceOf[Node | Null], (p, n) => { p.add(if (n == null) null else n, BorderLayout.SOUTH) })
  val Center: SwingVar.Aux[BorderPane, Node | Null] = SwingVar[BorderPane, Node | Null]("center", c => c.getLayout.asInstanceOf[BorderLayout].getLayoutComponent(BorderLayout.CENTER).asInstanceOf[Node | Null], (p, n) => { p.add(if (n == null) null else n, BorderLayout.CENTER) })
  val Hgap: SwingVar.Aux[BorderPane, Double] = SwingVar[BorderPane, Double]("hgap", c => c.getLayout.asInstanceOf[BorderLayout].getHgap, (p, g) => p.getLayout.asInstanceOf[BorderLayout].setHgap(g.toInt))
  val Left: SwingVar.Aux[BorderPane, Node | Null] = SwingVar[BorderPane, Node | Null]("left", c => c.getLayout.asInstanceOf[BorderLayout].getLayoutComponent(BorderLayout.WEST).asInstanceOf[Node | Null], (p, n) => { p.add(if (n == null) null else n, BorderLayout.WEST) })
  val Right: SwingVar.Aux[BorderPane, Node | Null] = SwingVar[BorderPane, Node | Null]("right", c => c.getLayout.asInstanceOf[BorderLayout].getLayoutComponent(BorderLayout.EAST).asInstanceOf[Node | Null], (p, n) => { p.add(if (n == null) null else n, BorderLayout.EAST) })
  val Top: SwingVar.Aux[BorderPane, Node | Null] = SwingVar[BorderPane, Node | Null]("top", c => c.getLayout.asInstanceOf[BorderLayout].getLayoutComponent(BorderLayout.NORTH).asInstanceOf[Node | Null], (p, n) => { p.add(if (n == null) null else n, BorderLayout.NORTH) })
  val Vgap: SwingVar.Aux[BorderPane, Double] = SwingVar[BorderPane, Double]("vgap", c => c.getLayout.asInstanceOf[BorderLayout].getVgap, (p, g) => p.getLayout.asInstanceOf[BorderLayout].setVgap(g.toInt))

  

  extension ops on (v: BorderPane) {
    def bottom: Var.Aux[Node | Null, v.type] = BorderPane.Bottom.forInstance(v)
    def center: Var.Aux[Node | Null, v.type] = BorderPane.Center.forInstance(v)
    def hgap: Var.Aux[Double, v.type] = BorderPane.Hgap.forInstance(v)
    def left: Var.Aux[Node | Null, v.type] = BorderPane.Left.forInstance(v)
    def right: Var.Aux[Node | Null, v.type] = BorderPane.Right.forInstance(v)
    def top: Var.Aux[Node | Null, v.type] = BorderPane.Top.forInstance(v)
    def vgap: Var.Aux[Double, v.type] = BorderPane.Vgap.forInstance(v)

    

    
    def unwrap: javax.swing.JPanel = v
  }

  def apply(v: javax.swing.JPanel) = v.asInstanceOf[BorderPane]

  def init(v: BorderPane): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Pane.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): BorderPane = {
    val res = javax.swing.JPanel().asInstanceOf[BorderPane]
    res.asInstanceOf[JPanel].setLayout(BorderLayout())
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.PanelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bottom: Opt[Binding[Node | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    center: Opt[Binding[Node | Null]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    hgap: Opt[Binding[Double]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    left: Opt[Binding[Node | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    right: Opt[Binding[Node | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    top: Opt[Binding[Node | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    vgap: Opt[Binding[Double]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[BorderPane] = {
    val res = uninitialized()
    BorderPane.init(res)
    ifSet(UI, Pane.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bottom, BorderPane.ops.bottom(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(center, BorderPane.ops.center(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(hgap, BorderPane.ops.hgap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(left, BorderPane.ops.left(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(right, BorderPane.ops.right(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(top, BorderPane.ops.top(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(vgap, BorderPane.ops.vgap(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type GridPane <: Pane = javax.swing.JPanel & Pane
object GridPane extends VarsMap {
  val AutoCreateContainerGaps: SwingVar.Aux[GridPane, Boolean] = SwingVar[GridPane, Boolean]("autoCreateContainerGaps", _.getLayout.asInstanceOf[GroupLayout].getAutoCreateContainerGaps(), _.getLayout.asInstanceOf[GroupLayout].setAutoCreateContainerGaps(_))
  val Hgap: Var[Double] = Var[Double]("hgap", 0.0)
  val LayoutVar: SwingVar.Aux[GridPane, Unit] = SwingVar[GridPane, Unit]("layoutVar", _ => (), (_, _) => ())
  val Rows: Var[Seq[Seq[Node]]] = Var[Seq[Seq[Node]]]("rows", Seq.empty)
  val Vgap: Var[Double] = Var[Double]("vgap", 0.0)

  

  extension ops on (v: GridPane) {
    def autoCreateContainerGaps: Var.Aux[Boolean, v.type] = GridPane.AutoCreateContainerGaps.forInstance(v)
    def hgap: Var.Aux[Double, v.type] = GridPane.Hgap.forInstance(v)
    def layoutVar: Var.Aux[Unit, v.type] = GridPane.LayoutVar.forInstance(v)
    def rows: Var.Aux[Seq[Seq[Node]], v.type] = GridPane.Rows.forInstance(v)
    def vgap: Var.Aux[Double, v.type] = GridPane.Vgap.forInstance(v)

    

    
    def unwrap: javax.swing.JPanel = v
  }

  def apply(v: javax.swing.JPanel) = v.asInstanceOf[GridPane]

  def init(v: GridPane): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Pane.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    sc.update(LayoutVar.forInstance(v) := Binding.dyn {
    val rows = v.rows()
    val hgap = v.hgap().toInt
    val vgap = v.vgap().toInt
    
    val layout = v.getLayout.asInstanceOf[GroupLayout]
    val hgroup = layout.createSequentialGroup().nn
    val vgroup = layout.createSequentialGroup().nn
    
    val hSeqGroups = collection.mutable.Map.empty[Int, GroupLayout#ParallelGroup]
    val vSeqGroups = collection.mutable.Map.empty[Int, GroupLayout#ParallelGroup]
    
    val rowSize = rows.size
    
    for {
      (row, rowIdx) <- rows.zipWithIndex
      colSize = row.length
      (node, colIdx) <- row.zipWithIndex
    } {
      hSeqGroups
        .getOrElseUpdate(colIdx, layout.createParallelGroup().nn.tap { g => 
          hgroup.addGroup(g)
          if (hgap > 0 && colIdx < colSize - 1) hgroup.addGap(hgap)
        })
        .addComponent(node)
    
      vSeqGroups
        .getOrElseUpdate(rowIdx, layout.createBaselineGroup(true, false).nn.tap { g => 
          vgroup.addGroup(g)
          if (vgap > 0 && rowIdx < rowSize - 1) vgroup.addGap(vgap)
        })
        .addComponent(node)
    }
    
    layout.setHorizontalGroup(hgroup)
    layout.setVerticalGroup(vgroup)
    })
    
  }
  def uninitialized(): GridPane = {
    val res = javax.swing.JPanel().asInstanceOf[GridPane]
    res.asInstanceOf[JPanel].setLayout(GroupLayout(res))
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.PanelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoCreateContainerGaps: Opt[Binding[Boolean]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    hgap: Opt[Binding[Double]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    layoutVar: Opt[Binding[Unit]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rows: Opt[Binding[Seq[Seq[Node]]]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    vgap: Opt[Binding[Double]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[GridPane] = {
    val res = uninitialized()
    GridPane.init(res)
    ifSet(UI, Pane.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoCreateContainerGaps, GridPane.ops.autoCreateContainerGaps(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(hgap, GridPane.ops.hgap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(layoutVar, GridPane.ops.layoutVar(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rows, GridPane.ops.rows(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(vgap, GridPane.ops.vgap(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Hbox <: Pane = javax.swing.JPanel & Pane
object Hbox extends VarsMap {
  val Nodes: SwingVar.Aux[Hbox, Seq[Node]] = SwingVar[Hbox, Seq[Node]]("nodes", c => (0 until c.getComponentCount).map(c.getComponent(_).asInstanceOf[Node]), (p, children) => { p.removeAll(); children foreach (n => p.add(n)) })

  

  extension ops on (v: Hbox) {
    def nodes: Var.Aux[Seq[Node], v.type] = Hbox.Nodes.forInstance(v)

    

    
    def unwrap: javax.swing.JPanel = v
  }

  def apply(v: javax.swing.JPanel) = v.asInstanceOf[Hbox]

  def init(v: Hbox): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Pane.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): Hbox = {
    val res = javax.swing.JPanel().asInstanceOf[Hbox]
    res.asInstanceOf[JPanel].setLayout(BoxLayout(res, BoxLayout.X_AXIS))
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.PanelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    nodes: Opt[Binding[Seq[Node]]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Hbox] = {
    val res = uninitialized()
    Hbox.init(res)
    ifSet(UI, Pane.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(nodes, Hbox.ops.nodes(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Vbox <: Pane = javax.swing.JPanel & Pane
object Vbox extends VarsMap {
  val Nodes: SwingVar.Aux[Vbox, Seq[Node]] = SwingVar[Vbox, Seq[Node]]("nodes", c => (0 until c.getComponentCount).map(c.getComponent(_).asInstanceOf[Node]), (p, children) => { p.removeAll(); children foreach (n => p.add(n)) })

  

  extension ops on (v: Vbox) {
    def nodes: Var.Aux[Seq[Node], v.type] = Vbox.Nodes.forInstance(v)

    

    
    def unwrap: javax.swing.JPanel = v
  }

  def apply(v: javax.swing.JPanel) = v.asInstanceOf[Vbox]

  def init(v: Vbox): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Pane.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): Vbox = {
    val res = javax.swing.JPanel().asInstanceOf[Vbox]
    res.asInstanceOf[JPanel].setLayout(BoxLayout(res, BoxLayout.Y_AXIS))
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.PanelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    nodes: Opt[Binding[Seq[Node]]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Vbox] = {
    val res = uninitialized()
    Vbox.init(res)
    ifSet(UI, Pane.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(nodes, Vbox.ops.nodes(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type TextComponent <: Component = javax.swing.text.JTextComponent & Component
object TextComponent extends VarsMap {
  val UI: SwingVar.Aux[TextComponent, javax.swing.plaf.TextUI] = SwingVar[TextComponent, javax.swing.plaf.TextUI]("UI", _.getUI.nn, _.setUI(_))
  val Caret: SwingVar.Aux[TextComponent, javax.swing.text.Caret] = SwingVar[TextComponent, javax.swing.text.Caret]("caret", _.getCaret.nn, _.setCaret(_))
  val CaretColor: SwingVar.Aux[TextComponent, java.awt.Color | Null] = SwingVar[TextComponent, java.awt.Color | Null]("caretColor", _.getCaretColor, _.setCaretColor(_))
  val DisabledTextColor: SwingVar.Aux[TextComponent, java.awt.Color | Null] = SwingVar[TextComponent, java.awt.Color | Null]("disabledTextColor", _.getDisabledTextColor, _.setDisabledTextColor(_))
  val Document: SwingVar.Aux[TextComponent, javax.swing.text.Document] = SwingVar[TextComponent, javax.swing.text.Document]("document", _.getDocument.nn, _.setDocument(_))
  val DragEnabled: SwingVar.Aux[TextComponent, Boolean] = SwingVar[TextComponent, Boolean]("dragEnabled", _.getDragEnabled, _.setDragEnabled(_))
  val DropMode: SwingVar.Aux[TextComponent, javax.swing.DropMode | Null] = SwingVar[TextComponent, javax.swing.DropMode | Null]("dropMode", _.getDropMode, _.setDropMode(_))
  val Editable: SwingVar.Aux[TextComponent, Boolean] = SwingVar[TextComponent, Boolean]("editable", _.isEditable, _.setEditable(_))
  val FocusAccelerator: SwingVar.Aux[TextComponent, Char] = SwingVar[TextComponent, Char]("focusAccelerator", _.getFocusAccelerator, _.setFocusAccelerator(_))
  val Highlighter: SwingVar.Aux[TextComponent, javax.swing.text.Highlighter | Null] = SwingVar[TextComponent, javax.swing.text.Highlighter | Null]("highlighter", _.getHighlighter, _.setHighlighter(_))
  val Keymap: SwingVar.Aux[TextComponent, javax.swing.text.Keymap | Null] = SwingVar[TextComponent, javax.swing.text.Keymap | Null]("keymap", _.getKeymap, _.setKeymap(_))
  val Margin: SwingVar.Aux[TextComponent, java.awt.Insets | Null] = SwingVar[TextComponent, java.awt.Insets | Null]("margin", _.getMargin, _.setMargin(_))
  val NavigationFilter: SwingVar.Aux[TextComponent, javax.swing.text.NavigationFilter | Null] = SwingVar[TextComponent, javax.swing.text.NavigationFilter | Null]("navigationFilter", _.getNavigationFilter, _.setNavigationFilter(_))
  val SelectedTextColor: SwingVar.Aux[TextComponent, java.awt.Color | Null] = SwingVar[TextComponent, java.awt.Color | Null]("selectedTextColor", _.getSelectedTextColor, _.setSelectedTextColor(_))
  val SelectionColor: SwingVar.Aux[TextComponent, java.awt.Color | Null] = SwingVar[TextComponent, java.awt.Color | Null]("selectionColor", _.getSelectionColor, _.setSelectionColor(_))

  

  extension ops on (v: TextComponent) {
    def UI: Var.Aux[javax.swing.plaf.TextUI, v.type] = TextComponent.UI.forInstance(v)
    def caret: Var.Aux[javax.swing.text.Caret, v.type] = TextComponent.Caret.forInstance(v)
    def caretColor: Var.Aux[java.awt.Color | Null, v.type] = TextComponent.CaretColor.forInstance(v)
    def disabledTextColor: Var.Aux[java.awt.Color | Null, v.type] = TextComponent.DisabledTextColor.forInstance(v)
    def document: Var.Aux[javax.swing.text.Document, v.type] = TextComponent.Document.forInstance(v)
    def dragEnabled: Var.Aux[Boolean, v.type] = TextComponent.DragEnabled.forInstance(v)
    def dropMode: Var.Aux[javax.swing.DropMode | Null, v.type] = TextComponent.DropMode.forInstance(v)
    def editable: Var.Aux[Boolean, v.type] = TextComponent.Editable.forInstance(v)
    def focusAccelerator: Var.Aux[Char, v.type] = TextComponent.FocusAccelerator.forInstance(v)
    def highlighter: Var.Aux[javax.swing.text.Highlighter | Null, v.type] = TextComponent.Highlighter.forInstance(v)
    def keymap: Var.Aux[javax.swing.text.Keymap | Null, v.type] = TextComponent.Keymap.forInstance(v)
    def margin: Var.Aux[java.awt.Insets | Null, v.type] = TextComponent.Margin.forInstance(v)
    def navigationFilter: Var.Aux[javax.swing.text.NavigationFilter | Null, v.type] = TextComponent.NavigationFilter.forInstance(v)
    def selectedTextColor: Var.Aux[java.awt.Color | Null, v.type] = TextComponent.SelectedTextColor.forInstance(v)
    def selectionColor: Var.Aux[java.awt.Color | Null, v.type] = TextComponent.SelectionColor.forInstance(v)

    

    def actions = v.getActions
    def caretListeners = v.getCaretListeners
    def dropLocation = v.getDropLocation
    def preferredScrollableViewportSize = v.getPreferredScrollableViewportSize
    def scrollableTracksViewportHeight = v.getScrollableTracksViewportHeight
    def scrollableTracksViewportWidth = v.getScrollableTracksViewportWidth
    def selectedText = v.getSelectedText
    def text = v.getText
    def text_=(s: String) = v.setText(s)
    def unwrap: javax.swing.text.JTextComponent = v
  }

  def apply(v: javax.swing.text.JTextComponent) = v.asInstanceOf[TextComponent]

  def init(v: TextComponent): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    v.getDocument.addDocumentListener(new DocumentListener {
      def changedUpdate(evt: DocumentEvent | Null) = notifyChange()
      def insertUpdate(evt: DocumentEvent | Null) = notifyChange()
      def removeUpdate(evt: DocumentEvent | Null) = notifyChange()
      def notifyChange() = summon[Scenegraph].update(summon[VarContext].swingPropertyUpdated(ops.document(v), v.getDocument.nn))
    })
    
  }
  
}

opaque type TextArea <: TextComponent = javax.swing.JTextArea & TextComponent
object TextArea extends VarsMap {
  val Columns: SwingVar.Aux[TextArea, Int] = SwingVar[TextArea, Int]("columns", _.getColumns, _.setColumns(_))
  val LineWrap: SwingVar.Aux[TextArea, Boolean] = SwingVar[TextArea, Boolean]("lineWrap", _.getLineWrap, _.setLineWrap(_))
  val Rows: SwingVar.Aux[TextArea, Int] = SwingVar[TextArea, Int]("rows", _.getRows, _.setRows(_))
  val TabSize: SwingVar.Aux[TextArea, Int] = SwingVar[TextArea, Int]("tabSize", _.getTabSize, _.setTabSize(_))
  val WrapStyleWord: SwingVar.Aux[TextArea, Boolean] = SwingVar[TextArea, Boolean]("wrapStyleWord", _.getWrapStyleWord, _.setWrapStyleWord(_))

  

  extension ops on (v: TextArea) {
    def columns: Var.Aux[Int, v.type] = TextArea.Columns.forInstance(v)
    def lineWrap: Var.Aux[Boolean, v.type] = TextArea.LineWrap.forInstance(v)
    def rows: Var.Aux[Int, v.type] = TextArea.Rows.forInstance(v)
    def tabSize: Var.Aux[Int, v.type] = TextArea.TabSize.forInstance(v)
    def wrapStyleWord: Var.Aux[Boolean, v.type] = TextArea.WrapStyleWord.forInstance(v)

    

    def lineCount = v.getLineCount
    def unwrap: javax.swing.JTextArea = v
  }

  def apply(v: javax.swing.JTextArea) = v.asInstanceOf[TextArea]

  def init(v: TextArea): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    TextComponent.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): TextArea = {
    val res = javax.swing.JTextArea().asInstanceOf[TextArea]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.TextUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    caret: Opt[Binding[javax.swing.text.Caret]] = UnsetParam,
    caretColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    columns: Opt[Binding[Int]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledTextColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    document: Opt[Binding[javax.swing.text.Document]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    dragEnabled: Opt[Binding[Boolean]] = UnsetParam,
    dropMode: Opt[Binding[javax.swing.DropMode | Null]] = UnsetParam,
    editable: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusAccelerator: Opt[Binding[Char]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    highlighter: Opt[Binding[javax.swing.text.Highlighter | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    keymap: Opt[Binding[javax.swing.text.Keymap | Null]] = UnsetParam,
    lineWrap: Opt[Binding[Boolean]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    navigationFilter: Opt[Binding[javax.swing.text.NavigationFilter | Null]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rows: Opt[Binding[Int]] = UnsetParam,
    selectedTextColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    selectionColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    tabSize: Opt[Binding[Int]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam,
    wrapStyleWord: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[TextArea] = {
    val res = uninitialized()
    TextArea.init(res)
    ifSet(UI, TextComponent.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(caret, TextComponent.ops.caret(res) := _)
    ifSet(caretColor, TextComponent.ops.caretColor(res) := _)
    ifSet(columns, TextArea.ops.columns(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledTextColor, TextComponent.ops.disabledTextColor(res) := _)
    ifSet(document, TextComponent.ops.document(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(dragEnabled, TextComponent.ops.dragEnabled(res) := _)
    ifSet(dropMode, TextComponent.ops.dropMode(res) := _)
    ifSet(editable, TextComponent.ops.editable(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusAccelerator, TextComponent.ops.focusAccelerator(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(highlighter, TextComponent.ops.highlighter(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(keymap, TextComponent.ops.keymap(res) := _)
    ifSet(lineWrap, TextArea.ops.lineWrap(res) := _)
    ifSet(margin, TextComponent.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(navigationFilter, TextComponent.ops.navigationFilter(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rows, TextArea.ops.rows(res) := _)
    ifSet(selectedTextColor, TextComponent.ops.selectedTextColor(res) := _)
    ifSet(selectionColor, TextComponent.ops.selectionColor(res) := _)
    ifSet(tabSize, TextArea.ops.tabSize(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    ifSet(wrapStyleWord, TextArea.ops.wrapStyleWord(res) := _)
    res
  }
}

opaque type TextField <: TextComponent = javax.swing.JTextField & TextComponent
object TextField extends VarsMap {
  val Action: SwingVar.Aux[TextField, javax.swing.Action | Null] = SwingVar[TextField, javax.swing.Action | Null]("action", _.getAction, _.setAction(_))
  val Columns: SwingVar.Aux[TextField, Int] = SwingVar[TextField, Int]("columns", _.getColumns, _.setColumns(_))
  val HorizontalAlignment: SwingVar.Aux[TextField, Int] = SwingVar[TextField, Int]("horizontalAlignment", _.getHorizontalAlignment, _.setHorizontalAlignment(_))
  val ScrollOffset: SwingVar.Aux[TextField, Int] = SwingVar[TextField, Int]("scrollOffset", _.getScrollOffset, _.setScrollOffset(_))

  

  extension ops on (v: TextField) {
    def action: Var.Aux[javax.swing.Action | Null, v.type] = TextField.Action.forInstance(v)
    def columns: Var.Aux[Int, v.type] = TextField.Columns.forInstance(v)
    def horizontalAlignment: Var.Aux[Int, v.type] = TextField.HorizontalAlignment.forInstance(v)
    def scrollOffset: Var.Aux[Int, v.type] = TextField.ScrollOffset.forInstance(v)

    

    def horizontalVisibility = v.getHorizontalVisibility
    def unwrap: javax.swing.JTextField = v
  }

  def apply(v: javax.swing.JTextField) = v.asInstanceOf[TextField]

  def init(v: TextField): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    TextComponent.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): TextField = {
    val res = javax.swing.JTextField().asInstanceOf[TextField]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.TextUI]] = UnsetParam,
    action: Opt[Binding[javax.swing.Action | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    caret: Opt[Binding[javax.swing.text.Caret]] = UnsetParam,
    caretColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    columns: Opt[Binding[Int]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledTextColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    document: Opt[Binding[javax.swing.text.Document]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    dragEnabled: Opt[Binding[Boolean]] = UnsetParam,
    dropMode: Opt[Binding[javax.swing.DropMode | Null]] = UnsetParam,
    editable: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusAccelerator: Opt[Binding[Char]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    highlighter: Opt[Binding[javax.swing.text.Highlighter | Null]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    keymap: Opt[Binding[javax.swing.text.Keymap | Null]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    navigationFilter: Opt[Binding[javax.swing.text.NavigationFilter | Null]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    scrollOffset: Opt[Binding[Int]] = UnsetParam,
    selectedTextColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    selectionColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[TextField] = {
    val res = uninitialized()
    TextField.init(res)
    ifSet(UI, TextComponent.ops.UI(res) := _)
    ifSet(action, TextField.ops.action(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(caret, TextComponent.ops.caret(res) := _)
    ifSet(caretColor, TextComponent.ops.caretColor(res) := _)
    ifSet(columns, TextField.ops.columns(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledTextColor, TextComponent.ops.disabledTextColor(res) := _)
    ifSet(document, TextComponent.ops.document(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(dragEnabled, TextComponent.ops.dragEnabled(res) := _)
    ifSet(dropMode, TextComponent.ops.dropMode(res) := _)
    ifSet(editable, TextComponent.ops.editable(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusAccelerator, TextComponent.ops.focusAccelerator(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(highlighter, TextComponent.ops.highlighter(res) := _)
    ifSet(horizontalAlignment, TextField.ops.horizontalAlignment(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(keymap, TextComponent.ops.keymap(res) := _)
    ifSet(margin, TextComponent.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(navigationFilter, TextComponent.ops.navigationFilter(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(scrollOffset, TextField.ops.scrollOffset(res) := _)
    ifSet(selectedTextColor, TextComponent.ops.selectedTextColor(res) := _)
    ifSet(selectionColor, TextComponent.ops.selectionColor(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type PasswordField <: TextField = javax.swing.JPasswordField & TextField
object PasswordField extends VarsMap {
  val EchoChar: SwingVar.Aux[PasswordField, Char] = SwingVar[PasswordField, Char]("echoChar", _.getEchoChar, _.setEchoChar(_))

  

  extension ops on (v: PasswordField) {
    def echoChar: Var.Aux[Char, v.type] = PasswordField.EchoChar.forInstance(v)

    

    def password = v.getPassword
    def unwrap: javax.swing.JPasswordField = v
  }

  def apply(v: javax.swing.JPasswordField) = v.asInstanceOf[PasswordField]

  def init(v: PasswordField): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    TextField.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): PasswordField = {
    val res = javax.swing.JPasswordField().asInstanceOf[PasswordField]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.TextUI]] = UnsetParam,
    action: Opt[Binding[javax.swing.Action | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    caret: Opt[Binding[javax.swing.text.Caret]] = UnsetParam,
    caretColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    columns: Opt[Binding[Int]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledTextColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    document: Opt[Binding[javax.swing.text.Document]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    dragEnabled: Opt[Binding[Boolean]] = UnsetParam,
    dropMode: Opt[Binding[javax.swing.DropMode | Null]] = UnsetParam,
    echoChar: Opt[Binding[Char]] = UnsetParam,
    editable: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusAccelerator: Opt[Binding[Char]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    highlighter: Opt[Binding[javax.swing.text.Highlighter | Null]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    keymap: Opt[Binding[javax.swing.text.Keymap | Null]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    navigationFilter: Opt[Binding[javax.swing.text.NavigationFilter | Null]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    scrollOffset: Opt[Binding[Int]] = UnsetParam,
    selectedTextColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    selectionColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[PasswordField] = {
    val res = uninitialized()
    PasswordField.init(res)
    ifSet(UI, TextComponent.ops.UI(res) := _)
    ifSet(action, TextField.ops.action(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(caret, TextComponent.ops.caret(res) := _)
    ifSet(caretColor, TextComponent.ops.caretColor(res) := _)
    ifSet(columns, TextField.ops.columns(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledTextColor, TextComponent.ops.disabledTextColor(res) := _)
    ifSet(document, TextComponent.ops.document(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(dragEnabled, TextComponent.ops.dragEnabled(res) := _)
    ifSet(dropMode, TextComponent.ops.dropMode(res) := _)
    ifSet(echoChar, PasswordField.ops.echoChar(res) := _)
    ifSet(editable, TextComponent.ops.editable(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusAccelerator, TextComponent.ops.focusAccelerator(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(highlighter, TextComponent.ops.highlighter(res) := _)
    ifSet(horizontalAlignment, TextField.ops.horizontalAlignment(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(keymap, TextComponent.ops.keymap(res) := _)
    ifSet(margin, TextComponent.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(navigationFilter, TextComponent.ops.navigationFilter(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(scrollOffset, TextField.ops.scrollOffset(res) := _)
    ifSet(selectedTextColor, TextComponent.ops.selectedTextColor(res) := _)
    ifSet(selectionColor, TextComponent.ops.selectionColor(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Label <: Component = javax.swing.JLabel & Component
object Label extends VarsMap {
  val UI: SwingVar.Aux[Label, javax.swing.plaf.LabelUI] = SwingVar[Label, javax.swing.plaf.LabelUI]("UI", _.getUI.nn, _.setUI(_))
  val DisabledIcon: SwingVar.Aux[Label, javax.swing.Icon | Null] = SwingVar[Label, javax.swing.Icon | Null]("disabledIcon", _.getDisabledIcon, _.setDisabledIcon(_))
  val DisplayedMnemonic: SwingVar.Aux[Label, Int] = SwingVar[Label, Int]("displayedMnemonic", _.getDisplayedMnemonic, _.setDisplayedMnemonic(_))
  val DisplayedMnemonicIndex: SwingVar.Aux[Label, Int] = SwingVar[Label, Int]("displayedMnemonicIndex", _.getDisplayedMnemonicIndex, _.setDisplayedMnemonicIndex(_))
  val HorizontalAlignment: SwingVar.Aux[Label, Int] = SwingVar[Label, Int]("horizontalAlignment", _.getHorizontalAlignment, _.setHorizontalAlignment(_))
  val HorizontalTextPosition: SwingVar.Aux[Label, Int] = SwingVar[Label, Int]("horizontalTextPosition", _.getHorizontalTextPosition, _.setHorizontalTextPosition(_))
  val Icon: SwingVar.Aux[Label, javax.swing.Icon | Null] = SwingVar[Label, javax.swing.Icon | Null]("icon", _.getIcon, _.setIcon(_))
  val IconTextGap: SwingVar.Aux[Label, Double] = SwingVar[Label, Double]("iconTextGap", _.getIconTextGap, (l, g) => l.setIconTextGap(g.toInt))
  val LabelFor: SwingVar.Aux[Label, java.awt.Component | Null] = SwingVar[Label, java.awt.Component | Null]("labelFor", _.getLabelFor, _.setLabelFor(_))
  val Text: SwingVar.Aux[Label, java.lang.String | Null] = SwingVar[Label, java.lang.String | Null]("text", _.getText, _.setText(_))
  val VerticalAlignment: SwingVar.Aux[Label, Int] = SwingVar[Label, Int]("verticalAlignment", _.getVerticalAlignment, _.setVerticalAlignment(_))
  val VerticalTextPosition: SwingVar.Aux[Label, Int] = SwingVar[Label, Int]("verticalTextPosition", _.getVerticalTextPosition, _.setVerticalTextPosition(_))

  

  extension ops on (v: Label) {
    def UI: Var.Aux[javax.swing.plaf.LabelUI, v.type] = Label.UI.forInstance(v)
    def disabledIcon: Var.Aux[javax.swing.Icon | Null, v.type] = Label.DisabledIcon.forInstance(v)
    def displayedMnemonic: Var.Aux[Int, v.type] = Label.DisplayedMnemonic.forInstance(v)
    def displayedMnemonicIndex: Var.Aux[Int, v.type] = Label.DisplayedMnemonicIndex.forInstance(v)
    def horizontalAlignment: Var.Aux[Int, v.type] = Label.HorizontalAlignment.forInstance(v)
    def horizontalTextPosition: Var.Aux[Int, v.type] = Label.HorizontalTextPosition.forInstance(v)
    def icon: Var.Aux[javax.swing.Icon | Null, v.type] = Label.Icon.forInstance(v)
    def iconTextGap: Var.Aux[Double, v.type] = Label.IconTextGap.forInstance(v)
    def labelFor: Var.Aux[java.awt.Component | Null, v.type] = Label.LabelFor.forInstance(v)
    def text: Var.Aux[java.lang.String | Null, v.type] = Label.Text.forInstance(v)
    def verticalAlignment: Var.Aux[Int, v.type] = Label.VerticalAlignment.forInstance(v)
    def verticalTextPosition: Var.Aux[Int, v.type] = Label.VerticalTextPosition.forInstance(v)

    

    
    def unwrap: javax.swing.JLabel = v
  }

  def apply(v: javax.swing.JLabel) = v.asInstanceOf[Label]

  def init(v: Label): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): Label = {
    val res = javax.swing.JLabel().asInstanceOf[Label]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.LabelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    displayedMnemonic: Opt[Binding[Int]] = UnsetParam,
    displayedMnemonicIndex: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    horizontalTextPosition: Opt[Binding[Int]] = UnsetParam,
    icon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    iconTextGap: Opt[Binding[Double]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    labelFor: Opt[Binding[java.awt.Component | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    text: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    verticalAlignment: Opt[Binding[Int]] = UnsetParam,
    verticalTextPosition: Opt[Binding[Int]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Label] = {
    val res = uninitialized()
    Label.init(res)
    ifSet(UI, Label.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledIcon, Label.ops.disabledIcon(res) := _)
    ifSet(displayedMnemonic, Label.ops.displayedMnemonic(res) := _)
    ifSet(displayedMnemonicIndex, Label.ops.displayedMnemonicIndex(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(horizontalAlignment, Label.ops.horizontalAlignment(res) := _)
    ifSet(horizontalTextPosition, Label.ops.horizontalTextPosition(res) := _)
    ifSet(icon, Label.ops.icon(res) := _)
    ifSet(iconTextGap, Label.ops.iconTextGap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(labelFor, Label.ops.labelFor(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(text, Label.ops.text(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(verticalAlignment, Label.ops.verticalAlignment(res) := _)
    ifSet(verticalTextPosition, Label.ops.verticalTextPosition(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type ButtonBase <: Component = javax.swing.AbstractButton & Component
object ButtonBase extends VarsMap {
  val UI: SwingVar.Aux[ButtonBase, javax.swing.plaf.ButtonUI] = SwingVar[ButtonBase, javax.swing.plaf.ButtonUI]("UI", _.getUI.nn, _.setUI(_))
  val Action: SwingVar.Aux[ButtonBase, javax.swing.Action | Null] = SwingVar[ButtonBase, javax.swing.Action | Null]("action", _.getAction, _.setAction(_))
  val ActionCommand: SwingVar.Aux[ButtonBase, java.lang.String | Null] = SwingVar[ButtonBase, java.lang.String | Null]("actionCommand", _.getActionCommand, _.setActionCommand(_))
  val BorderPainted: SwingVar.Aux[ButtonBase, Boolean] = SwingVar[ButtonBase, Boolean]("borderPainted", _.isBorderPainted, _.setBorderPainted(_))
  val ContentAreaFilled: SwingVar.Aux[ButtonBase, Boolean] = SwingVar[ButtonBase, Boolean]("contentAreaFilled", _.isContentAreaFilled, _.setContentAreaFilled(_))
  val DisabledIcon: SwingVar.Aux[ButtonBase, javax.swing.Icon | Null] = SwingVar[ButtonBase, javax.swing.Icon | Null]("disabledIcon", _.getDisabledIcon, _.setDisabledIcon(_))
  val DisabledSelectedIcon: SwingVar.Aux[ButtonBase, javax.swing.Icon | Null] = SwingVar[ButtonBase, javax.swing.Icon | Null]("disabledSelectedIcon", _.getDisabledSelectedIcon, _.setDisabledSelectedIcon(_))
  val DisplayedMnemonicIndex: SwingVar.Aux[ButtonBase, Int] = SwingVar[ButtonBase, Int]("displayedMnemonicIndex", _.getDisplayedMnemonicIndex, _.setDisplayedMnemonicIndex(_))
  val FocusPainted: SwingVar.Aux[ButtonBase, Boolean] = SwingVar[ButtonBase, Boolean]("focusPainted", _.isFocusPainted, _.setFocusPainted(_))
  val HideActionText: SwingVar.Aux[ButtonBase, Boolean] = SwingVar[ButtonBase, Boolean]("hideActionText", _.getHideActionText, _.setHideActionText(_))
  val HorizontalAlignment: SwingVar.Aux[ButtonBase, Int] = SwingVar[ButtonBase, Int]("horizontalAlignment", _.getHorizontalAlignment, _.setHorizontalAlignment(_))
  val HorizontalTextPosition: SwingVar.Aux[ButtonBase, Int] = SwingVar[ButtonBase, Int]("horizontalTextPosition", _.getHorizontalTextPosition, _.setHorizontalTextPosition(_))
  val Icon: SwingVar.Aux[ButtonBase, javax.swing.Icon | Null] = SwingVar[ButtonBase, javax.swing.Icon | Null]("icon", _.getIcon, _.setIcon(_))
  val IconTextGap: SwingVar.Aux[ButtonBase, Int] = SwingVar[ButtonBase, Int]("iconTextGap", _.getIconTextGap, _.setIconTextGap(_))
  val Label: SwingVar.Aux[ButtonBase, java.lang.String | Null] = SwingVar[ButtonBase, java.lang.String | Null]("label", _.getLabel, _.setLabel(_))
  val Margin: SwingVar.Aux[ButtonBase, java.awt.Insets | Null] = SwingVar[ButtonBase, java.awt.Insets | Null]("margin", _.getMargin, _.setMargin(_))
  val Mnemonic: SwingVar.Aux[ButtonBase, Int] = SwingVar[ButtonBase, Int]("mnemonic", _.getMnemonic, _.setMnemonic(_))
  val Model: SwingVar.Aux[ButtonBase, javax.swing.ButtonModel | Null] = SwingVar[ButtonBase, javax.swing.ButtonModel | Null]("model", _.getModel, _.setModel(_))
  val MultiClickThreshhold: SwingVar.Aux[ButtonBase, Long] = SwingVar[ButtonBase, Long]("multiClickThreshhold", _.getMultiClickThreshhold, _.setMultiClickThreshhold(_))
  val PressedIcon: SwingVar.Aux[ButtonBase, javax.swing.Icon | Null] = SwingVar[ButtonBase, javax.swing.Icon | Null]("pressedIcon", _.getPressedIcon, _.setPressedIcon(_))
  val RolloverEnabled: SwingVar.Aux[ButtonBase, Boolean] = SwingVar[ButtonBase, Boolean]("rolloverEnabled", _.isRolloverEnabled, _.setRolloverEnabled(_))
  val RolloverIcon: SwingVar.Aux[ButtonBase, javax.swing.Icon | Null] = SwingVar[ButtonBase, javax.swing.Icon | Null]("rolloverIcon", _.getRolloverIcon, _.setRolloverIcon(_))
  val RolloverSelectedIcon: SwingVar.Aux[ButtonBase, javax.swing.Icon | Null] = SwingVar[ButtonBase, javax.swing.Icon | Null]("rolloverSelectedIcon", _.getRolloverSelectedIcon, _.setRolloverSelectedIcon(_))
  val Selected: SwingVar.Aux[ButtonBase, Boolean] = SwingVar[ButtonBase, Boolean]("selected", _.isSelected, _.setSelected(_))
  val SelectedIcon: SwingVar.Aux[ButtonBase, javax.swing.Icon | Null] = SwingVar[ButtonBase, javax.swing.Icon | Null]("selectedIcon", _.getSelectedIcon, _.setSelectedIcon(_))
  val Text: SwingVar.Aux[ButtonBase, java.lang.String | Null] = SwingVar[ButtonBase, java.lang.String | Null]("text", _.getText, _.setText(_))
  val VerticalAlignment: SwingVar.Aux[ButtonBase, Int] = SwingVar[ButtonBase, Int]("verticalAlignment", _.getVerticalAlignment, _.setVerticalAlignment(_))
  val VerticalTextPosition: SwingVar.Aux[ButtonBase, Int] = SwingVar[ButtonBase, Int]("verticalTextPosition", _.getVerticalTextPosition, _.setVerticalTextPosition(_))

  val ActionEvents = Emitter[java.awt.event.ActionEvent]()

  extension ops on (v: ButtonBase) {
    def UI: Var.Aux[javax.swing.plaf.ButtonUI, v.type] = ButtonBase.UI.forInstance(v)
    def action: Var.Aux[javax.swing.Action | Null, v.type] = ButtonBase.Action.forInstance(v)
    def actionCommand: Var.Aux[java.lang.String | Null, v.type] = ButtonBase.ActionCommand.forInstance(v)
    def borderPainted: Var.Aux[Boolean, v.type] = ButtonBase.BorderPainted.forInstance(v)
    def contentAreaFilled: Var.Aux[Boolean, v.type] = ButtonBase.ContentAreaFilled.forInstance(v)
    def disabledIcon: Var.Aux[javax.swing.Icon | Null, v.type] = ButtonBase.DisabledIcon.forInstance(v)
    def disabledSelectedIcon: Var.Aux[javax.swing.Icon | Null, v.type] = ButtonBase.DisabledSelectedIcon.forInstance(v)
    def displayedMnemonicIndex: Var.Aux[Int, v.type] = ButtonBase.DisplayedMnemonicIndex.forInstance(v)
    def focusPainted: Var.Aux[Boolean, v.type] = ButtonBase.FocusPainted.forInstance(v)
    def hideActionText: Var.Aux[Boolean, v.type] = ButtonBase.HideActionText.forInstance(v)
    def horizontalAlignment: Var.Aux[Int, v.type] = ButtonBase.HorizontalAlignment.forInstance(v)
    def horizontalTextPosition: Var.Aux[Int, v.type] = ButtonBase.HorizontalTextPosition.forInstance(v)
    def icon: Var.Aux[javax.swing.Icon | Null, v.type] = ButtonBase.Icon.forInstance(v)
    def iconTextGap: Var.Aux[Int, v.type] = ButtonBase.IconTextGap.forInstance(v)
    def label: Var.Aux[java.lang.String | Null, v.type] = ButtonBase.Label.forInstance(v)
    def margin: Var.Aux[java.awt.Insets | Null, v.type] = ButtonBase.Margin.forInstance(v)
    def mnemonic: Var.Aux[Int, v.type] = ButtonBase.Mnemonic.forInstance(v)
    def model: Var.Aux[javax.swing.ButtonModel | Null, v.type] = ButtonBase.Model.forInstance(v)
    def multiClickThreshhold: Var.Aux[Long, v.type] = ButtonBase.MultiClickThreshhold.forInstance(v)
    def pressedIcon: Var.Aux[javax.swing.Icon | Null, v.type] = ButtonBase.PressedIcon.forInstance(v)
    def rolloverEnabled: Var.Aux[Boolean, v.type] = ButtonBase.RolloverEnabled.forInstance(v)
    def rolloverIcon: Var.Aux[javax.swing.Icon | Null, v.type] = ButtonBase.RolloverIcon.forInstance(v)
    def rolloverSelectedIcon: Var.Aux[javax.swing.Icon | Null, v.type] = ButtonBase.RolloverSelectedIcon.forInstance(v)
    def selected: Var.Aux[Boolean, v.type] = ButtonBase.Selected.forInstance(v)
    def selectedIcon: Var.Aux[javax.swing.Icon | Null, v.type] = ButtonBase.SelectedIcon.forInstance(v)
    def text: Var.Aux[java.lang.String | Null, v.type] = ButtonBase.Text.forInstance(v)
    def verticalAlignment: Var.Aux[Int, v.type] = ButtonBase.VerticalAlignment.forInstance(v)
    def verticalTextPosition: Var.Aux[Int, v.type] = ButtonBase.VerticalTextPosition.forInstance(v)

    def actionEvents: Emitter.Aux[java.awt.event.ActionEvent, v.type] = ButtonBase.ActionEvents.forInstance(v)

    def actionListeners = v.getActionListeners
    def changeListeners = v.getChangeListeners
    def itemListeners = v.getItemListeners
    def selectedObjects = v.getSelectedObjects
    def unwrap: javax.swing.AbstractButton = v
  }

  def apply(v: javax.swing.AbstractButton) = v.asInstanceOf[ButtonBase]

  def init(v: ButtonBase): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    sc.update {
      val ctx = summon[Emitter.Context]
      ctx.register(v.actionEvents)
    }
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    val al: java.awt.event.ActionListener = evt => sc.update(summon[Emitter.Context].emit(v.actionEvents, evt.nn))
    v.addActionListener(al)

    var wasSelected = v.isSelected
    val cl: javax.swing.event.ChangeListener = evt => sc.update {
      val ctx = summon[VarContext]
      if (v.isSelected != wasSelected)
        ctx.swingPropertyUpdated(ops.selected(v), v.isSelected)
      wasSelected = v.isSelected
    }
    v.addChangeListener(cl)
  }
  
}

opaque type Button <: ButtonBase = javax.swing.JButton & ButtonBase
object Button extends VarsMap {
  val DefaultCapable: SwingVar.Aux[Button, Boolean] = SwingVar[Button, Boolean]("defaultCapable", _.isDefaultCapable, _.setDefaultCapable(_))

  

  extension ops on (v: Button) {
    def defaultCapable: Var.Aux[Boolean, v.type] = Button.DefaultCapable.forInstance(v)

    

    def defaultButton = v.isDefaultButton
    def unwrap: javax.swing.JButton = v
  }

  def apply(v: javax.swing.JButton) = v.asInstanceOf[Button]

  def init(v: Button): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    ButtonBase.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): Button = {
    val res = javax.swing.JButton().asInstanceOf[Button]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.ButtonUI]] = UnsetParam,
    action: Opt[Binding[javax.swing.Action | Null]] = UnsetParam,
    actionCommand: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    borderPainted: Opt[Binding[Boolean]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    contentAreaFilled: Opt[Binding[Boolean]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    defaultCapable: Opt[Binding[Boolean]] = UnsetParam,
    disabledIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    disabledSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    displayedMnemonicIndex: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusPainted: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    hideActionText: Opt[Binding[Boolean]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    horizontalTextPosition: Opt[Binding[Int]] = UnsetParam,
    icon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    iconTextGap: Opt[Binding[Int]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    label: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mnemonic: Opt[Binding[Int]] = UnsetParam,
    model: Opt[Binding[javax.swing.ButtonModel | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    multiClickThreshhold: Opt[Binding[Long]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    pressedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    rolloverSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    selected: Opt[Binding[Boolean]] = UnsetParam,
    selectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    text: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    verticalAlignment: Opt[Binding[Int]] = UnsetParam,
    verticalTextPosition: Opt[Binding[Int]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Button] = {
    val res = uninitialized()
    Button.init(res)
    ifSet(UI, ButtonBase.ops.UI(res) := _)
    ifSet(action, ButtonBase.ops.action(res) := _)
    ifSet(actionCommand, ButtonBase.ops.actionCommand(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(borderPainted, ButtonBase.ops.borderPainted(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(contentAreaFilled, ButtonBase.ops.contentAreaFilled(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(defaultCapable, Button.ops.defaultCapable(res) := _)
    ifSet(disabledIcon, ButtonBase.ops.disabledIcon(res) := _)
    ifSet(disabledSelectedIcon, ButtonBase.ops.disabledSelectedIcon(res) := _)
    ifSet(displayedMnemonicIndex, ButtonBase.ops.displayedMnemonicIndex(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusPainted, ButtonBase.ops.focusPainted(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(hideActionText, ButtonBase.ops.hideActionText(res) := _)
    ifSet(horizontalAlignment, ButtonBase.ops.horizontalAlignment(res) := _)
    ifSet(horizontalTextPosition, ButtonBase.ops.horizontalTextPosition(res) := _)
    ifSet(icon, ButtonBase.ops.icon(res) := _)
    ifSet(iconTextGap, ButtonBase.ops.iconTextGap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(label, ButtonBase.ops.label(res) := _)
    ifSet(margin, ButtonBase.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mnemonic, ButtonBase.ops.mnemonic(res) := _)
    ifSet(model, ButtonBase.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(multiClickThreshhold, ButtonBase.ops.multiClickThreshhold(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(pressedIcon, ButtonBase.ops.pressedIcon(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rolloverEnabled, ButtonBase.ops.rolloverEnabled(res) := _)
    ifSet(rolloverIcon, ButtonBase.ops.rolloverIcon(res) := _)
    ifSet(rolloverSelectedIcon, ButtonBase.ops.rolloverSelectedIcon(res) := _)
    ifSet(selected, ButtonBase.ops.selected(res) := _)
    ifSet(selectedIcon, ButtonBase.ops.selectedIcon(res) := _)
    ifSet(text, ButtonBase.ops.text(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(verticalAlignment, ButtonBase.ops.verticalAlignment(res) := _)
    ifSet(verticalTextPosition, ButtonBase.ops.verticalTextPosition(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type ToggleButton <: ButtonBase = javax.swing.JToggleButton & ButtonBase
object ToggleButton extends VarsMap {
  

  

  extension ops on (v: ToggleButton) {
    

    

    
    def unwrap: javax.swing.JToggleButton = v
  }

  def apply(v: javax.swing.JToggleButton) = v.asInstanceOf[ToggleButton]

  def init(v: ToggleButton): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    ButtonBase.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): ToggleButton = {
    val res = javax.swing.JToggleButton().asInstanceOf[ToggleButton]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.ButtonUI]] = UnsetParam,
    action: Opt[Binding[javax.swing.Action | Null]] = UnsetParam,
    actionCommand: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    borderPainted: Opt[Binding[Boolean]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    contentAreaFilled: Opt[Binding[Boolean]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    disabledSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    displayedMnemonicIndex: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusPainted: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    hideActionText: Opt[Binding[Boolean]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    horizontalTextPosition: Opt[Binding[Int]] = UnsetParam,
    icon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    iconTextGap: Opt[Binding[Int]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    label: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mnemonic: Opt[Binding[Int]] = UnsetParam,
    model: Opt[Binding[javax.swing.ButtonModel | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    multiClickThreshhold: Opt[Binding[Long]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    pressedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    rolloverSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    selected: Opt[Binding[Boolean]] = UnsetParam,
    selectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    text: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    verticalAlignment: Opt[Binding[Int]] = UnsetParam,
    verticalTextPosition: Opt[Binding[Int]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[ToggleButton] = {
    val res = uninitialized()
    ToggleButton.init(res)
    ifSet(UI, ButtonBase.ops.UI(res) := _)
    ifSet(action, ButtonBase.ops.action(res) := _)
    ifSet(actionCommand, ButtonBase.ops.actionCommand(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(borderPainted, ButtonBase.ops.borderPainted(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(contentAreaFilled, ButtonBase.ops.contentAreaFilled(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledIcon, ButtonBase.ops.disabledIcon(res) := _)
    ifSet(disabledSelectedIcon, ButtonBase.ops.disabledSelectedIcon(res) := _)
    ifSet(displayedMnemonicIndex, ButtonBase.ops.displayedMnemonicIndex(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusPainted, ButtonBase.ops.focusPainted(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(hideActionText, ButtonBase.ops.hideActionText(res) := _)
    ifSet(horizontalAlignment, ButtonBase.ops.horizontalAlignment(res) := _)
    ifSet(horizontalTextPosition, ButtonBase.ops.horizontalTextPosition(res) := _)
    ifSet(icon, ButtonBase.ops.icon(res) := _)
    ifSet(iconTextGap, ButtonBase.ops.iconTextGap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(label, ButtonBase.ops.label(res) := _)
    ifSet(margin, ButtonBase.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mnemonic, ButtonBase.ops.mnemonic(res) := _)
    ifSet(model, ButtonBase.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(multiClickThreshhold, ButtonBase.ops.multiClickThreshhold(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(pressedIcon, ButtonBase.ops.pressedIcon(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rolloverEnabled, ButtonBase.ops.rolloverEnabled(res) := _)
    ifSet(rolloverIcon, ButtonBase.ops.rolloverIcon(res) := _)
    ifSet(rolloverSelectedIcon, ButtonBase.ops.rolloverSelectedIcon(res) := _)
    ifSet(selected, ButtonBase.ops.selected(res) := _)
    ifSet(selectedIcon, ButtonBase.ops.selectedIcon(res) := _)
    ifSet(text, ButtonBase.ops.text(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(verticalAlignment, ButtonBase.ops.verticalAlignment(res) := _)
    ifSet(verticalTextPosition, ButtonBase.ops.verticalTextPosition(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type CheckBox <: ToggleButton = javax.swing.JCheckBox & ToggleButton
object CheckBox extends VarsMap {
  val BorderPaintedFlat: SwingVar.Aux[CheckBox, Boolean] = SwingVar[CheckBox, Boolean]("borderPaintedFlat", _.isBorderPaintedFlat, _.setBorderPaintedFlat(_))

  

  extension ops on (v: CheckBox) {
    def borderPaintedFlat: Var.Aux[Boolean, v.type] = CheckBox.BorderPaintedFlat.forInstance(v)

    

    
    def unwrap: javax.swing.JCheckBox = v
  }

  def apply(v: javax.swing.JCheckBox) = v.asInstanceOf[CheckBox]

  def init(v: CheckBox): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    ToggleButton.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): CheckBox = {
    val res = javax.swing.JCheckBox().asInstanceOf[CheckBox]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.ButtonUI]] = UnsetParam,
    action: Opt[Binding[javax.swing.Action | Null]] = UnsetParam,
    actionCommand: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    borderPainted: Opt[Binding[Boolean]] = UnsetParam,
    borderPaintedFlat: Opt[Binding[Boolean]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    contentAreaFilled: Opt[Binding[Boolean]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    disabledSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    displayedMnemonicIndex: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusPainted: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    hideActionText: Opt[Binding[Boolean]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    horizontalTextPosition: Opt[Binding[Int]] = UnsetParam,
    icon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    iconTextGap: Opt[Binding[Int]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    label: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mnemonic: Opt[Binding[Int]] = UnsetParam,
    model: Opt[Binding[javax.swing.ButtonModel | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    multiClickThreshhold: Opt[Binding[Long]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    pressedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    rolloverSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    selected: Opt[Binding[Boolean]] = UnsetParam,
    selectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    text: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    verticalAlignment: Opt[Binding[Int]] = UnsetParam,
    verticalTextPosition: Opt[Binding[Int]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[CheckBox] = {
    val res = uninitialized()
    CheckBox.init(res)
    ifSet(UI, ButtonBase.ops.UI(res) := _)
    ifSet(action, ButtonBase.ops.action(res) := _)
    ifSet(actionCommand, ButtonBase.ops.actionCommand(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(borderPainted, ButtonBase.ops.borderPainted(res) := _)
    ifSet(borderPaintedFlat, CheckBox.ops.borderPaintedFlat(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(contentAreaFilled, ButtonBase.ops.contentAreaFilled(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledIcon, ButtonBase.ops.disabledIcon(res) := _)
    ifSet(disabledSelectedIcon, ButtonBase.ops.disabledSelectedIcon(res) := _)
    ifSet(displayedMnemonicIndex, ButtonBase.ops.displayedMnemonicIndex(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusPainted, ButtonBase.ops.focusPainted(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(hideActionText, ButtonBase.ops.hideActionText(res) := _)
    ifSet(horizontalAlignment, ButtonBase.ops.horizontalAlignment(res) := _)
    ifSet(horizontalTextPosition, ButtonBase.ops.horizontalTextPosition(res) := _)
    ifSet(icon, ButtonBase.ops.icon(res) := _)
    ifSet(iconTextGap, ButtonBase.ops.iconTextGap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(label, ButtonBase.ops.label(res) := _)
    ifSet(margin, ButtonBase.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mnemonic, ButtonBase.ops.mnemonic(res) := _)
    ifSet(model, ButtonBase.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(multiClickThreshhold, ButtonBase.ops.multiClickThreshhold(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(pressedIcon, ButtonBase.ops.pressedIcon(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rolloverEnabled, ButtonBase.ops.rolloverEnabled(res) := _)
    ifSet(rolloverIcon, ButtonBase.ops.rolloverIcon(res) := _)
    ifSet(rolloverSelectedIcon, ButtonBase.ops.rolloverSelectedIcon(res) := _)
    ifSet(selected, ButtonBase.ops.selected(res) := _)
    ifSet(selectedIcon, ButtonBase.ops.selectedIcon(res) := _)
    ifSet(text, ButtonBase.ops.text(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(verticalAlignment, ButtonBase.ops.verticalAlignment(res) := _)
    ifSet(verticalTextPosition, ButtonBase.ops.verticalTextPosition(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type RadioButton <: ToggleButton = javax.swing.JRadioButton & ToggleButton
object RadioButton extends VarsMap {
  

  

  extension ops on (v: RadioButton) {
    

    

    
    def unwrap: javax.swing.JRadioButton = v
  }

  def apply(v: javax.swing.JRadioButton) = v.asInstanceOf[RadioButton]

  def init(v: RadioButton): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    ToggleButton.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): RadioButton = {
    val res = javax.swing.JRadioButton().asInstanceOf[RadioButton]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.ButtonUI]] = UnsetParam,
    action: Opt[Binding[javax.swing.Action | Null]] = UnsetParam,
    actionCommand: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    borderPainted: Opt[Binding[Boolean]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    contentAreaFilled: Opt[Binding[Boolean]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    disabledSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    displayedMnemonicIndex: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusPainted: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    hideActionText: Opt[Binding[Boolean]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    horizontalTextPosition: Opt[Binding[Int]] = UnsetParam,
    icon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    iconTextGap: Opt[Binding[Int]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    label: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mnemonic: Opt[Binding[Int]] = UnsetParam,
    model: Opt[Binding[javax.swing.ButtonModel | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    multiClickThreshhold: Opt[Binding[Long]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    pressedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    rolloverSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    selected: Opt[Binding[Boolean]] = UnsetParam,
    selectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    text: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    verticalAlignment: Opt[Binding[Int]] = UnsetParam,
    verticalTextPosition: Opt[Binding[Int]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[RadioButton] = {
    val res = uninitialized()
    RadioButton.init(res)
    ifSet(UI, ButtonBase.ops.UI(res) := _)
    ifSet(action, ButtonBase.ops.action(res) := _)
    ifSet(actionCommand, ButtonBase.ops.actionCommand(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(borderPainted, ButtonBase.ops.borderPainted(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(contentAreaFilled, ButtonBase.ops.contentAreaFilled(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledIcon, ButtonBase.ops.disabledIcon(res) := _)
    ifSet(disabledSelectedIcon, ButtonBase.ops.disabledSelectedIcon(res) := _)
    ifSet(displayedMnemonicIndex, ButtonBase.ops.displayedMnemonicIndex(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusPainted, ButtonBase.ops.focusPainted(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(hideActionText, ButtonBase.ops.hideActionText(res) := _)
    ifSet(horizontalAlignment, ButtonBase.ops.horizontalAlignment(res) := _)
    ifSet(horizontalTextPosition, ButtonBase.ops.horizontalTextPosition(res) := _)
    ifSet(icon, ButtonBase.ops.icon(res) := _)
    ifSet(iconTextGap, ButtonBase.ops.iconTextGap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(label, ButtonBase.ops.label(res) := _)
    ifSet(margin, ButtonBase.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mnemonic, ButtonBase.ops.mnemonic(res) := _)
    ifSet(model, ButtonBase.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(multiClickThreshhold, ButtonBase.ops.multiClickThreshhold(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(pressedIcon, ButtonBase.ops.pressedIcon(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rolloverEnabled, ButtonBase.ops.rolloverEnabled(res) := _)
    ifSet(rolloverIcon, ButtonBase.ops.rolloverIcon(res) := _)
    ifSet(rolloverSelectedIcon, ButtonBase.ops.rolloverSelectedIcon(res) := _)
    ifSet(selected, ButtonBase.ops.selected(res) := _)
    ifSet(selectedIcon, ButtonBase.ops.selectedIcon(res) := _)
    ifSet(text, ButtonBase.ops.text(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(verticalAlignment, ButtonBase.ops.verticalAlignment(res) := _)
    ifSet(verticalTextPosition, ButtonBase.ops.verticalTextPosition(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Slider <: Component = javax.swing.JSlider & Component
object Slider extends VarsMap {
  val UI: SwingVar.Aux[Slider, javax.swing.plaf.SliderUI] = SwingVar[Slider, javax.swing.plaf.SliderUI]("UI", _.getUI.nn, _.setUI(_))
  val Extent: SwingVar.Aux[Slider, Int] = SwingVar[Slider, Int]("extent", _.getExtent, _.setExtent(_))
  val Inverted: SwingVar.Aux[Slider, Boolean] = SwingVar[Slider, Boolean]("inverted", _.getInverted, _.setInverted(_))
  val LabelTable: SwingVar.Aux[Slider, java.util.Dictionary[_, _] | Null] = SwingVar[Slider, java.util.Dictionary[_, _] | Null]("labelTable", _.getLabelTable, _.setLabelTable(_))
  val MajorTickSpacing: SwingVar.Aux[Slider, Int] = SwingVar[Slider, Int]("majorTickSpacing", _.getMajorTickSpacing, _.setMajorTickSpacing(_))
  val Max: SwingVar.Aux[Slider, Int] = SwingVar[Slider, Int]("max", _.getMaximum, _.setMaximum(_))
  val Min: SwingVar.Aux[Slider, Int] = SwingVar[Slider, Int]("min", _.getMinimum, _.setMinimum(_))
  val MinorTickSpacing: SwingVar.Aux[Slider, Int] = SwingVar[Slider, Int]("minorTickSpacing", _.getMinorTickSpacing, _.setMinorTickSpacing(_))
  val Model: SwingVar.Aux[Slider, javax.swing.BoundedRangeModel | Null] = SwingVar[Slider, javax.swing.BoundedRangeModel | Null]("model", _.getModel, _.setModel(_))
  val Orientation: SwingVar.Aux[Slider, Int] = SwingVar[Slider, Int]("orientation", _.getOrientation, _.setOrientation(_))
  val PaintLabels: SwingVar.Aux[Slider, Boolean] = SwingVar[Slider, Boolean]("paintLabels", _.getPaintLabels, _.setPaintLabels(_))
  val PaintTicks: SwingVar.Aux[Slider, Boolean] = SwingVar[Slider, Boolean]("paintTicks", _.getPaintTicks, _.setPaintTicks(_))
  val PaintTrack: SwingVar.Aux[Slider, Boolean] = SwingVar[Slider, Boolean]("paintTrack", _.getPaintTrack, _.setPaintTrack(_))
  val SnapToTicks: SwingVar.Aux[Slider, Boolean] = SwingVar[Slider, Boolean]("snapToTicks", _.getSnapToTicks, _.setSnapToTicks(_))
  val Value: SwingVar.Aux[Slider, Int] = SwingVar[Slider, Int]("value", _.getValue, _.setValue(_))
  val ValueIsAdjusting: SwingVar.Aux[Slider, Boolean] = SwingVar[Slider, Boolean]("valueIsAdjusting", _.getValueIsAdjusting, _.setValueIsAdjusting(_))

  

  extension ops on (v: Slider) {
    def UI: Var.Aux[javax.swing.plaf.SliderUI, v.type] = Slider.UI.forInstance(v)
    def extent: Var.Aux[Int, v.type] = Slider.Extent.forInstance(v)
    def inverted: Var.Aux[Boolean, v.type] = Slider.Inverted.forInstance(v)
    def labelTable: Var.Aux[java.util.Dictionary[_, _] | Null, v.type] = Slider.LabelTable.forInstance(v)
    def majorTickSpacing: Var.Aux[Int, v.type] = Slider.MajorTickSpacing.forInstance(v)
    def max: Var.Aux[Int, v.type] = Slider.Max.forInstance(v)
    def min: Var.Aux[Int, v.type] = Slider.Min.forInstance(v)
    def minorTickSpacing: Var.Aux[Int, v.type] = Slider.MinorTickSpacing.forInstance(v)
    def model: Var.Aux[javax.swing.BoundedRangeModel | Null, v.type] = Slider.Model.forInstance(v)
    def orientation: Var.Aux[Int, v.type] = Slider.Orientation.forInstance(v)
    def paintLabels: Var.Aux[Boolean, v.type] = Slider.PaintLabels.forInstance(v)
    def paintTicks: Var.Aux[Boolean, v.type] = Slider.PaintTicks.forInstance(v)
    def paintTrack: Var.Aux[Boolean, v.type] = Slider.PaintTrack.forInstance(v)
    def snapToTicks: Var.Aux[Boolean, v.type] = Slider.SnapToTicks.forInstance(v)
    def value: Var.Aux[Int, v.type] = Slider.Value.forInstance(v)
    def valueIsAdjusting: Var.Aux[Boolean, v.type] = Slider.ValueIsAdjusting.forInstance(v)

    

    def changeListeners = v.getChangeListeners
    def unwrap: javax.swing.JSlider = v
  }

  def apply(v: javax.swing.JSlider) = v.asInstanceOf[Slider]

  def init(v: Slider): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    val l: ChangeListener = (e: ChangeEvent | UncheckedNull) => summon[Scenegraph].update(summon[VarContext].swingPropertyUpdated(ops.value(v), v.getValue))
    v.addChangeListener(l)
    
  }
  def uninitialized(): Slider = {
    val res = javax.swing.JSlider().asInstanceOf[Slider]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.SliderUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    extent: Opt[Binding[Int]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    inverted: Opt[Binding[Boolean]] = UnsetParam,
    labelTable: Opt[Binding[java.util.Dictionary[_, _] | Null]] = UnsetParam,
    majorTickSpacing: Opt[Binding[Int]] = UnsetParam,
    max: Opt[Binding[Int]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    min: Opt[Binding[Int]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minorTickSpacing: Opt[Binding[Int]] = UnsetParam,
    model: Opt[Binding[javax.swing.BoundedRangeModel | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    orientation: Opt[Binding[Int]] = UnsetParam,
    paintLabels: Opt[Binding[Boolean]] = UnsetParam,
    paintTicks: Opt[Binding[Boolean]] = UnsetParam,
    paintTrack: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    snapToTicks: Opt[Binding[Boolean]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    value: Opt[Binding[Int]] = UnsetParam,
    valueIsAdjusting: Opt[Binding[Boolean]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Slider] = {
    val res = uninitialized()
    Slider.init(res)
    ifSet(UI, Slider.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(extent, Slider.ops.extent(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(inverted, Slider.ops.inverted(res) := _)
    ifSet(labelTable, Slider.ops.labelTable(res) := _)
    ifSet(majorTickSpacing, Slider.ops.majorTickSpacing(res) := _)
    ifSet(max, Slider.ops.max(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(min, Slider.ops.min(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(minorTickSpacing, Slider.ops.minorTickSpacing(res) := _)
    ifSet(model, Slider.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(orientation, Slider.ops.orientation(res) := _)
    ifSet(paintLabels, Slider.ops.paintLabels(res) := _)
    ifSet(paintTicks, Slider.ops.paintTicks(res) := _)
    ifSet(paintTrack, Slider.ops.paintTrack(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(snapToTicks, Slider.ops.snapToTicks(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(value, Slider.ops.value(res) := _)
    ifSet(valueIsAdjusting, Slider.ops.valueIsAdjusting(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type ProgressBar <: Component = javax.swing.JProgressBar & Component
object ProgressBar extends VarsMap {
  val UI: SwingVar.Aux[ProgressBar, javax.swing.plaf.ProgressBarUI] = SwingVar[ProgressBar, javax.swing.plaf.ProgressBarUI]("UI", _.getUI.nn, _.setUI(_))
  val BorderPainted: SwingVar.Aux[ProgressBar, Boolean] = SwingVar[ProgressBar, Boolean]("borderPainted", _.isBorderPainted, _.setBorderPainted(_))
  val Indeterminate: SwingVar.Aux[ProgressBar, Boolean] = SwingVar[ProgressBar, Boolean]("indeterminate", _.isIndeterminate, _.setIndeterminate(_))
  val Max: SwingVar.Aux[ProgressBar, Int] = SwingVar[ProgressBar, Int]("max", _.getMaximum, _.setMaximum(_))
  val Min: SwingVar.Aux[ProgressBar, Int] = SwingVar[ProgressBar, Int]("min", _.getMinimum, _.setMinimum(_))
  val Model: SwingVar.Aux[ProgressBar, javax.swing.BoundedRangeModel | Null] = SwingVar[ProgressBar, javax.swing.BoundedRangeModel | Null]("model", _.getModel, _.setModel(_))
  val Orientation: SwingVar.Aux[ProgressBar, Int] = SwingVar[ProgressBar, Int]("orientation", _.getOrientation, _.setOrientation(_))
  val String: SwingVar.Aux[ProgressBar, java.lang.String | Null] = SwingVar[ProgressBar, java.lang.String | Null]("string", _.getString, _.setString(_))
  val StringPainted: SwingVar.Aux[ProgressBar, Boolean] = SwingVar[ProgressBar, Boolean]("stringPainted", _.isStringPainted, _.setStringPainted(_))
  val Value: SwingVar.Aux[ProgressBar, Int] = SwingVar[ProgressBar, Int]("value", _.getValue, _.setValue(_))

  

  extension ops on (v: ProgressBar) {
    def UI: Var.Aux[javax.swing.plaf.ProgressBarUI, v.type] = ProgressBar.UI.forInstance(v)
    def borderPainted: Var.Aux[Boolean, v.type] = ProgressBar.BorderPainted.forInstance(v)
    def indeterminate: Var.Aux[Boolean, v.type] = ProgressBar.Indeterminate.forInstance(v)
    def max: Var.Aux[Int, v.type] = ProgressBar.Max.forInstance(v)
    def min: Var.Aux[Int, v.type] = ProgressBar.Min.forInstance(v)
    def model: Var.Aux[javax.swing.BoundedRangeModel | Null, v.type] = ProgressBar.Model.forInstance(v)
    def orientation: Var.Aux[Int, v.type] = ProgressBar.Orientation.forInstance(v)
    def string: Var.Aux[java.lang.String | Null, v.type] = ProgressBar.String.forInstance(v)
    def stringPainted: Var.Aux[Boolean, v.type] = ProgressBar.StringPainted.forInstance(v)
    def value: Var.Aux[Int, v.type] = ProgressBar.Value.forInstance(v)

    

    def changeListeners = v.getChangeListeners
    def percentComplete = v.getPercentComplete
    def unwrap: javax.swing.JProgressBar = v
  }

  def apply(v: javax.swing.JProgressBar) = v.asInstanceOf[ProgressBar]

  def init(v: ProgressBar): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    val l: ChangeListener = (e: ChangeEvent | UncheckedNull) => summon[Scenegraph].update(summon[VarContext].swingPropertyUpdated(ops.value(v), v.getValue))
    v.addChangeListener(l)
    
  }
  def uninitialized(): ProgressBar = {
    val res = javax.swing.JProgressBar().asInstanceOf[ProgressBar]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.ProgressBarUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    borderPainted: Opt[Binding[Boolean]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    indeterminate: Opt[Binding[Boolean]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    max: Opt[Binding[Int]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    min: Opt[Binding[Int]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    model: Opt[Binding[javax.swing.BoundedRangeModel | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    orientation: Opt[Binding[Int]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    string: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    stringPainted: Opt[Binding[Boolean]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    value: Opt[Binding[Int]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[ProgressBar] = {
    val res = uninitialized()
    ProgressBar.init(res)
    ifSet(UI, ProgressBar.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(borderPainted, ProgressBar.ops.borderPainted(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(indeterminate, ProgressBar.ops.indeterminate(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(max, ProgressBar.ops.max(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(min, ProgressBar.ops.min(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(model, ProgressBar.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(orientation, ProgressBar.ops.orientation(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(string, ProgressBar.ops.string(res) := _)
    ifSet(stringPainted, ProgressBar.ops.stringPainted(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(value, ProgressBar.ops.value(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type ListView[+E] <: Component = javax.swing.JList[_ <: E] & Component
object ListView extends VarsMap {
  val UI: SwingVar.Aux[ListView[Any], javax.swing.plaf.ListUI | Null] = SwingVar[ListView[Any], javax.swing.plaf.ListUI | Null]("UI", _.getUI, _.setUI(_))
  val CellRenderer: SwingVar.Aux[ListView[Any], javax.swing.ListCellRenderer[_]] = SwingVar[ListView[Any], javax.swing.ListCellRenderer[_]]("cellRenderer", _.getCellRenderer.nn, (l, c) => l.setCellRenderer(c.asInstanceOf))
  val DragEnabled: SwingVar.Aux[ListView[Any], Boolean] = SwingVar[ListView[Any], Boolean]("dragEnabled", _.getDragEnabled, _.setDragEnabled(_))
  val DropMode: SwingVar.Aux[ListView[Any], javax.swing.DropMode | Null] = SwingVar[ListView[Any], javax.swing.DropMode | Null]("dropMode", _.getDropMode, _.setDropMode(_))
  val FixedCellHeight: SwingVar.Aux[ListView[Any], Int] = SwingVar[ListView[Any], Int]("fixedCellHeight", _.getFixedCellHeight, _.setFixedCellHeight(_))
  val FixedCellWidth: SwingVar.Aux[ListView[Any], Int] = SwingVar[ListView[Any], Int]("fixedCellWidth", _.getFixedCellWidth, _.setFixedCellWidth(_))
  val LayoutOrientation: SwingVar.Aux[ListView[Any], Int] = SwingVar[ListView[Any], Int]("layoutOrientation", _.getLayoutOrientation, _.setLayoutOrientation(_))
  val Model: SwingVar.Aux[ListView[Any], javax.swing.ListModel[_]] = SwingVar[ListView[Any], javax.swing.ListModel[_]]("model", _.getModel.nn, (l, m) => l.setModel(m.asInstanceOf))
  val PrototypeCellValue: SwingVar.Aux[ListView[Any], Any] = SwingVar[ListView[Any], Any]("prototypeCellValue", _.getPrototypeCellValue, (l, p) => l.setPrototypeCellValue(p.asInstanceOf))
  val SelectedIndex: SwingVar.Aux[ListView[Any], Int] = SwingVar[ListView[Any], Int]("selectedIndex", _.getSelectedIndex, _.setSelectedIndex(_))
  val SelectedIndices: SwingVar.Aux[ListView[Any], Array[Int]] = SwingVar[ListView[Any], Array[Int]]("selectedIndices", _.getSelectedIndices.nn, _.setSelectedIndices(_))
  val SelectionBackground: SwingVar.Aux[ListView[Any], java.awt.Color | Null] = SwingVar[ListView[Any], java.awt.Color | Null]("selectionBackground", _.getSelectionBackground, _.setSelectionBackground(_))
  val SelectionForeground: SwingVar.Aux[ListView[Any], java.awt.Color | Null] = SwingVar[ListView[Any], java.awt.Color | Null]("selectionForeground", _.getSelectionForeground, _.setSelectionForeground(_))
  val SelectionMode: SwingVar.Aux[ListView[Any], Int] = SwingVar[ListView[Any], Int]("selectionMode", _.getSelectionMode, _.setSelectionMode(_))
  val SelectionModel: SwingVar.Aux[ListView[Any], javax.swing.ListSelectionModel] = SwingVar[ListView[Any], javax.swing.ListSelectionModel]("selectionModel", _.getSelectionModel.nn, _.setSelectionModel(_))
  val ValueIsAdjusting: SwingVar.Aux[ListView[Any], Boolean] = SwingVar[ListView[Any], Boolean]("valueIsAdjusting", _.getValueIsAdjusting, _.setValueIsAdjusting(_))
  val VisibleRowCount: SwingVar.Aux[ListView[Any], Int] = SwingVar[ListView[Any], Int]("visibleRowCount", _.getVisibleRowCount, _.setVisibleRowCount(_))

  

  extension ops on [E](v: ListView[E]) {
    def UI: Var.Aux[javax.swing.plaf.ListUI | Null, v.type] = ListView.UI.asInstanceOf[Var.Aux[javax.swing.plaf.ListUI | Null, v.type]]
    def cellRenderer: Var.Aux[javax.swing.ListCellRenderer[_ >: E], v.type] = ListView.CellRenderer.asInstanceOf[Var.Aux[javax.swing.ListCellRenderer[_ >: E], v.type]]
    def dragEnabled: Var.Aux[Boolean, v.type] = ListView.DragEnabled.asInstanceOf[Var.Aux[Boolean, v.type]]
    def dropMode: Var.Aux[javax.swing.DropMode | Null, v.type] = ListView.DropMode.asInstanceOf[Var.Aux[javax.swing.DropMode | Null, v.type]]
    def fixedCellHeight: Var.Aux[Int, v.type] = ListView.FixedCellHeight.asInstanceOf[Var.Aux[Int, v.type]]
    def fixedCellWidth: Var.Aux[Int, v.type] = ListView.FixedCellWidth.asInstanceOf[Var.Aux[Int, v.type]]
    def layoutOrientation: Var.Aux[Int, v.type] = ListView.LayoutOrientation.asInstanceOf[Var.Aux[Int, v.type]]
    def model: Var.Aux[javax.swing.ListModel[E], v.type] = ListView.Model.asInstanceOf[Var.Aux[javax.swing.ListModel[E], v.type]]
    def prototypeCellValue: Var.Aux[E | Null, v.type] = ListView.PrototypeCellValue.asInstanceOf[Var.Aux[E | Null, v.type]]
    def selectedIndex: Var.Aux[Int, v.type] = ListView.SelectedIndex.asInstanceOf[Var.Aux[Int, v.type]]
    def selectedIndices: Var.Aux[Array[Int], v.type] = ListView.SelectedIndices.asInstanceOf[Var.Aux[Array[Int], v.type]]
    def selectionBackground: Var.Aux[java.awt.Color | Null, v.type] = ListView.SelectionBackground.asInstanceOf[Var.Aux[java.awt.Color | Null, v.type]]
    def selectionForeground: Var.Aux[java.awt.Color | Null, v.type] = ListView.SelectionForeground.asInstanceOf[Var.Aux[java.awt.Color | Null, v.type]]
    def selectionMode: Var.Aux[Int, v.type] = ListView.SelectionMode.asInstanceOf[Var.Aux[Int, v.type]]
    def selectionModel: Var.Aux[javax.swing.ListSelectionModel, v.type] = ListView.SelectionModel.asInstanceOf[Var.Aux[javax.swing.ListSelectionModel, v.type]]
    def valueIsAdjusting: Var.Aux[Boolean, v.type] = ListView.ValueIsAdjusting.asInstanceOf[Var.Aux[Boolean, v.type]]
    def visibleRowCount: Var.Aux[Int, v.type] = ListView.VisibleRowCount.asInstanceOf[Var.Aux[Int, v.type]]

    

    def anchorSelectionIndex: Int = v.getAnchorSelectionIndex
    def dropLocation: javax.swing.JList.DropLocation | Null = v.getDropLocation
    def firstVisibleIndex: Int = v.getFirstVisibleIndex
    def lastVisibleIndex: Int = v.getLastVisibleIndex
    def leadSelectionIndex: Int = v.getLeadSelectionIndex
    def listSelectionListeners: Array[javax.swing.event.ListSelectionListener] = v.getListSelectionListeners.asInstanceOf[Array[javax.swing.event.ListSelectionListener]]
    def maxSelectionIndex: Int = v.getMaxSelectionIndex
    def minSelectionIndex: Int = v.getMinSelectionIndex
    def preferredScrollableViewportSize: java.awt.Dimension | Null = v.getPreferredScrollableViewportSize
    def scrollableTracksViewportHeight: Boolean = v.getScrollableTracksViewportHeight
    def scrollableTracksViewportWidth: Boolean = v.getScrollableTracksViewportWidth
    def selectedValue: Option[E] = { val r = v.getSelectedValue; if (r == null) None else Some(r) }
    def selectedValues: Seq[E] = v.getSelectedValuesList.nn.asScala.asInstanceOf
    def selectionEmpty: Boolean = v.isSelectionEmpty
    def unwrap: javax.swing.JList[_ <: E] = v
  }

  def apply[E](v: javax.swing.JList[_ <: E]) = v.asInstanceOf[ListView[E]]

  def init[E](v: ListView[E]): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    val lsl: ListSelectionListener = (evt) => sc.update{
      val vc = summon[VarContext]
      vc.swingPropertyUpdated(ops.selectedIndex(v), v.getSelectedIndex)
      vc.swingPropertyUpdated(ops.selectedIndices(v), v.getSelectedIndices.nn)
      vc.swingPropertyUpdated(ops.selectedIndices(v), v.getSelectedIndices.nn)
    }
    v.addListSelectionListener(lsl)
        
    
  }
  def uninitialized[E](): ListView[E] = {
    val res = javax.swing.JList[E]().asInstanceOf[ListView[E]]
    
    res
  }
  
  def apply[E](
    
    UI: Opt[Binding[javax.swing.plaf.ListUI | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    cellRenderer: Opt[Binding[javax.swing.ListCellRenderer[_ >: E]]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    dragEnabled: Opt[Binding[Boolean]] = UnsetParam,
    dropMode: Opt[Binding[javax.swing.DropMode | Null]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    fixedCellHeight: Opt[Binding[Int]] = UnsetParam,
    fixedCellWidth: Opt[Binding[Int]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    layoutOrientation: Opt[Binding[Int]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    model: Opt[Binding[javax.swing.ListModel[E]]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    prototypeCellValue: Opt[Binding[E | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    selectedIndex: Opt[Binding[Int]] = UnsetParam,
    selectedIndices: Opt[Binding[Array[Int]]] = UnsetParam,
    selectionBackground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    selectionForeground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    selectionMode: Opt[Binding[Int]] = UnsetParam,
    selectionModel: Opt[Binding[javax.swing.ListSelectionModel]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    valueIsAdjusting: Opt[Binding[Boolean]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam,
    visibleRowCount: Opt[Binding[Int]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[ListView[E]] = {
    val res = uninitialized[E]()
    ListView.init(res)
    ifSet(UI, ListView.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(cellRenderer, ListView.ops.cellRenderer(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(dragEnabled, ListView.ops.dragEnabled(res) := _)
    ifSet(dropMode, ListView.ops.dropMode(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(fixedCellHeight, ListView.ops.fixedCellHeight(res) := _)
    ifSet(fixedCellWidth, ListView.ops.fixedCellWidth(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(layoutOrientation, ListView.ops.layoutOrientation(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(model, ListView.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(prototypeCellValue, ListView.ops.prototypeCellValue(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(selectedIndex, ListView.ops.selectedIndex(res) := _)
    ifSet(selectedIndices, ListView.ops.selectedIndices(res) := _)
    ifSet(selectionBackground, ListView.ops.selectionBackground(res) := _)
    ifSet(selectionForeground, ListView.ops.selectionForeground(res) := _)
    ifSet(selectionMode, ListView.ops.selectionMode(res) := _)
    ifSet(selectionModel, ListView.ops.selectionModel(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(valueIsAdjusting, ListView.ops.valueIsAdjusting(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    ifSet(visibleRowCount, ListView.ops.visibleRowCount(res) := _)
    res
  }
}

opaque type TableView <: Component = javax.swing.JTable & Component
object TableView extends VarsMap {
  val UI: SwingVar.Aux[TableView, javax.swing.plaf.TableUI] = SwingVar[TableView, javax.swing.plaf.TableUI]("UI", _.getUI.nn, _.setUI(_))
  val AutoCreateColumnsFromModel: SwingVar.Aux[TableView, Boolean] = SwingVar[TableView, Boolean]("autoCreateColumnsFromModel", _.getAutoCreateColumnsFromModel, _.setAutoCreateColumnsFromModel(_))
  val AutoCreateRowSorter: SwingVar.Aux[TableView, Boolean] = SwingVar[TableView, Boolean]("autoCreateRowSorter", _.getAutoCreateRowSorter, _.setAutoCreateRowSorter(_))
  val AutoResizeMode: SwingVar.Aux[TableView, Int] = SwingVar[TableView, Int]("autoResizeMode", _.getAutoResizeMode, _.setAutoResizeMode(_))
  val CellEditor: SwingVar.Aux[TableView, javax.swing.table.TableCellEditor] = SwingVar[TableView, javax.swing.table.TableCellEditor]("cellEditor", _.getCellEditor.nn, _.setCellEditor(_))
  val CellSelectionEnabled: SwingVar.Aux[TableView, Boolean] = SwingVar[TableView, Boolean]("cellSelectionEnabled", _.getCellSelectionEnabled, _.setCellSelectionEnabled(_))
  val ColumnModel: SwingVar.Aux[TableView, javax.swing.table.TableColumnModel] = SwingVar[TableView, javax.swing.table.TableColumnModel]("columnModel", _.getColumnModel.nn, _.setColumnModel(_))
  val ColumnSelectionAllowed: SwingVar.Aux[TableView, Boolean] = SwingVar[TableView, Boolean]("columnSelectionAllowed", _.getColumnSelectionAllowed, _.setColumnSelectionAllowed(_))
  val DragEnabled: SwingVar.Aux[TableView, Boolean] = SwingVar[TableView, Boolean]("dragEnabled", _.getDragEnabled, _.setDragEnabled(_))
  val DropMode: SwingVar.Aux[TableView, javax.swing.DropMode | Null] = SwingVar[TableView, javax.swing.DropMode | Null]("dropMode", _.getDropMode, _.setDropMode(_))
  val EditingColumn: SwingVar.Aux[TableView, Int] = SwingVar[TableView, Int]("editingColumn", _.getEditingColumn, _.setEditingColumn(_))
  val EditingRow: SwingVar.Aux[TableView, Int] = SwingVar[TableView, Int]("editingRow", _.getEditingRow, _.setEditingRow(_))
  val FillsViewportHeight: SwingVar.Aux[TableView, Boolean] = SwingVar[TableView, Boolean]("fillsViewportHeight", _.getFillsViewportHeight, _.setFillsViewportHeight(_))
  val GridColor: SwingVar.Aux[TableView, java.awt.Color | Null] = SwingVar[TableView, java.awt.Color | Null]("gridColor", _.getGridColor, _.setGridColor(_))
  val IntercellSpacing: SwingVar.Aux[TableView, (Double, Double) | Null] = SwingVar[TableView, (Double, Double) | Null]("intercellSpacing", {n => val d = n.getIntercellSpacing; if (d != null) (d.getWidth, d.getHeight) else null}, {(n, d) => n.setIntercellSpacing(if (d == null) null else java.awt.Dimension(d._1.toInt, d._2.toInt))})
  val Model: SwingVar.Aux[TableView, javax.swing.table.TableModel] = SwingVar[TableView, javax.swing.table.TableModel]("model", _.getModel.nn, _.setModel(_))
  val PreferredScrollableViewportSize: SwingVar.Aux[TableView, (Double, Double) | Null] = SwingVar[TableView, (Double, Double) | Null]("preferredScrollableViewportSize", {n => val d = n.getPreferredScrollableViewportSize; if (d != null) (d.getWidth, d.getHeight) else null}, {(n, d) => n.setPreferredScrollableViewportSize(if (d == null) null else java.awt.Dimension(d._1.toInt, d._2.toInt))})
  val RowHeight: SwingVar.Aux[TableView, Int] = SwingVar[TableView, Int]("rowHeight", _.getRowHeight, _.setRowHeight(_))
  val RowMargin: SwingVar.Aux[TableView, Int] = SwingVar[TableView, Int]("rowMargin", _.getRowMargin, _.setRowMargin(_))
  val RowSelectionAllowed: SwingVar.Aux[TableView, Boolean] = SwingVar[TableView, Boolean]("rowSelectionAllowed", _.getRowSelectionAllowed, _.setRowSelectionAllowed(_))
  val RowSorter: SwingVar.Aux[TableView, javax.swing.RowSorter[_ <: javax.swing.table.TableModel] | Null] = SwingVar[TableView, javax.swing.RowSorter[_ <: javax.swing.table.TableModel] | Null]("rowSorter", _.getRowSorter, _.setRowSorter(_))
  val SelectionBackground: SwingVar.Aux[TableView, java.awt.Color | Null] = SwingVar[TableView, java.awt.Color | Null]("selectionBackground", _.getSelectionBackground, _.setSelectionBackground(_))
  val SelectionForeground: SwingVar.Aux[TableView, java.awt.Color | Null] = SwingVar[TableView, java.awt.Color | Null]("selectionForeground", _.getSelectionForeground, _.setSelectionForeground(_))
  val SelectionModel: SwingVar.Aux[TableView, javax.swing.ListSelectionModel] = SwingVar[TableView, javax.swing.ListSelectionModel]("selectionModel", _.getSelectionModel.nn, _.setSelectionModel(_))
  val ShowHorizontalLines: SwingVar.Aux[TableView, Boolean] = SwingVar[TableView, Boolean]("showHorizontalLines", _.getShowHorizontalLines, _.setShowHorizontalLines(_))
  val ShowVerticalLines: SwingVar.Aux[TableView, Boolean] = SwingVar[TableView, Boolean]("showVerticalLines", _.getShowVerticalLines, _.setShowVerticalLines(_))
  val SurrendersFocusOnKeystroke: SwingVar.Aux[TableView, Boolean] = SwingVar[TableView, Boolean]("surrendersFocusOnKeystroke", _.getSurrendersFocusOnKeystroke, _.setSurrendersFocusOnKeystroke(_))
  val TableHeader: SwingVar.Aux[TableView, javax.swing.table.JTableHeader | Null] = SwingVar[TableView, javax.swing.table.JTableHeader | Null]("tableHeader", _.getTableHeader, _.setTableHeader(_))
  val UpdateSelectionOnSort: SwingVar.Aux[TableView, Boolean] = SwingVar[TableView, Boolean]("updateSelectionOnSort", _.getUpdateSelectionOnSort, _.setUpdateSelectionOnSort(_))

  

  extension ops on (v: TableView) {
    def UI: Var.Aux[javax.swing.plaf.TableUI, v.type] = TableView.UI.asInstanceOf[Var.Aux[javax.swing.plaf.TableUI, v.type]]
    def autoCreateColumnsFromModel: Var.Aux[Boolean, v.type] = TableView.AutoCreateColumnsFromModel.asInstanceOf[Var.Aux[Boolean, v.type]]
    def autoCreateRowSorter: Var.Aux[Boolean, v.type] = TableView.AutoCreateRowSorter.asInstanceOf[Var.Aux[Boolean, v.type]]
    def autoResizeMode: Var.Aux[Int, v.type] = TableView.AutoResizeMode.asInstanceOf[Var.Aux[Int, v.type]]
    def cellEditor: Var.Aux[javax.swing.table.TableCellEditor, v.type] = TableView.CellEditor.asInstanceOf[Var.Aux[javax.swing.table.TableCellEditor, v.type]]
    def cellSelectionEnabled: Var.Aux[Boolean, v.type] = TableView.CellSelectionEnabled.asInstanceOf[Var.Aux[Boolean, v.type]]
    def columnModel: Var.Aux[javax.swing.table.TableColumnModel, v.type] = TableView.ColumnModel.asInstanceOf[Var.Aux[javax.swing.table.TableColumnModel, v.type]]
    def columnSelectionAllowed: Var.Aux[Boolean, v.type] = TableView.ColumnSelectionAllowed.asInstanceOf[Var.Aux[Boolean, v.type]]
    def dragEnabled: Var.Aux[Boolean, v.type] = TableView.DragEnabled.asInstanceOf[Var.Aux[Boolean, v.type]]
    def dropMode: Var.Aux[javax.swing.DropMode | Null, v.type] = TableView.DropMode.asInstanceOf[Var.Aux[javax.swing.DropMode | Null, v.type]]
    def editingColumn: Var.Aux[Int, v.type] = TableView.EditingColumn.asInstanceOf[Var.Aux[Int, v.type]]
    def editingRow: Var.Aux[Int, v.type] = TableView.EditingRow.asInstanceOf[Var.Aux[Int, v.type]]
    def fillsViewportHeight: Var.Aux[Boolean, v.type] = TableView.FillsViewportHeight.asInstanceOf[Var.Aux[Boolean, v.type]]
    def gridColor: Var.Aux[java.awt.Color | Null, v.type] = TableView.GridColor.asInstanceOf[Var.Aux[java.awt.Color | Null, v.type]]
    def intercellSpacing: Var.Aux[(Double, Double) | Null, v.type] = TableView.IntercellSpacing.asInstanceOf[Var.Aux[(Double, Double) | Null, v.type]]
    def model: Var.Aux[javax.swing.table.TableModel, v.type] = TableView.Model.asInstanceOf[Var.Aux[javax.swing.table.TableModel, v.type]]
    def preferredScrollableViewportSize: Var.Aux[(Double, Double) | Null, v.type] = TableView.PreferredScrollableViewportSize.asInstanceOf[Var.Aux[(Double, Double) | Null, v.type]]
    def rowHeight: Var.Aux[Int, v.type] = TableView.RowHeight.asInstanceOf[Var.Aux[Int, v.type]]
    def rowMargin: Var.Aux[Int, v.type] = TableView.RowMargin.asInstanceOf[Var.Aux[Int, v.type]]
    def rowSelectionAllowed: Var.Aux[Boolean, v.type] = TableView.RowSelectionAllowed.asInstanceOf[Var.Aux[Boolean, v.type]]
    def rowSorter: Var.Aux[javax.swing.RowSorter[_ <: javax.swing.table.TableModel] | Null, v.type] = TableView.RowSorter.asInstanceOf[Var.Aux[javax.swing.RowSorter[_ <: javax.swing.table.TableModel] | Null, v.type]]
    def selectionBackground: Var.Aux[java.awt.Color | Null, v.type] = TableView.SelectionBackground.asInstanceOf[Var.Aux[java.awt.Color | Null, v.type]]
    def selectionForeground: Var.Aux[java.awt.Color | Null, v.type] = TableView.SelectionForeground.asInstanceOf[Var.Aux[java.awt.Color | Null, v.type]]
    def selectionModel: Var.Aux[javax.swing.ListSelectionModel, v.type] = TableView.SelectionModel.asInstanceOf[Var.Aux[javax.swing.ListSelectionModel, v.type]]
    def showHorizontalLines: Var.Aux[Boolean, v.type] = TableView.ShowHorizontalLines.asInstanceOf[Var.Aux[Boolean, v.type]]
    def showVerticalLines: Var.Aux[Boolean, v.type] = TableView.ShowVerticalLines.asInstanceOf[Var.Aux[Boolean, v.type]]
    def surrendersFocusOnKeystroke: Var.Aux[Boolean, v.type] = TableView.SurrendersFocusOnKeystroke.asInstanceOf[Var.Aux[Boolean, v.type]]
    def tableHeader: Var.Aux[javax.swing.table.JTableHeader | Null, v.type] = TableView.TableHeader.asInstanceOf[Var.Aux[javax.swing.table.JTableHeader | Null, v.type]]
    def updateSelectionOnSort: Var.Aux[Boolean, v.type] = TableView.UpdateSelectionOnSort.asInstanceOf[Var.Aux[Boolean, v.type]]

    

    def columnCount: Int = v.getColumnCount
    def dropLocation: javax.swing.JTable.DropLocation | Null = v.getDropLocation
    def editing: Boolean = v.isEditing
    def editorComponent: java.awt.Component | Null = v.getEditorComponent
    def rowCount: Int = v.getRowCount
    def scrollableTracksViewportHeight: Boolean = v.getScrollableTracksViewportHeight
    def scrollableTracksViewportWidth: Boolean = v.getScrollableTracksViewportWidth
    def selectedColumn: Int = v.getSelectedColumn
    def selectedColumnCount: Int = v.getSelectedColumnCount
    def selectedColumns: Array[Int] = v.getSelectedColumns.nn
    def selectedRow: Int = v.getSelectedRow
    def selectedRowCount: Int = v.getSelectedRowCount
    def selectedRows: Array[Int] = v.getSelectedRows.nn
    def unwrap: javax.swing.JTable = v
  }

  def apply(v: javax.swing.JTable) = v.asInstanceOf[TableView]

  def init(v: TableView): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): TableView = {
    val res = javax.swing.JTable().asInstanceOf[TableView]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.TableUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoCreateColumnsFromModel: Opt[Binding[Boolean]] = UnsetParam,
    autoCreateRowSorter: Opt[Binding[Boolean]] = UnsetParam,
    autoResizeMode: Opt[Binding[Int]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    cellEditor: Opt[Binding[javax.swing.table.TableCellEditor]] = UnsetParam,
    cellSelectionEnabled: Opt[Binding[Boolean]] = UnsetParam,
    columnModel: Opt[Binding[javax.swing.table.TableColumnModel]] = UnsetParam,
    columnSelectionAllowed: Opt[Binding[Boolean]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    dragEnabled: Opt[Binding[Boolean]] = UnsetParam,
    dropMode: Opt[Binding[javax.swing.DropMode | Null]] = UnsetParam,
    editingColumn: Opt[Binding[Int]] = UnsetParam,
    editingRow: Opt[Binding[Int]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    fillsViewportHeight: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    gridColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    intercellSpacing: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    model: Opt[Binding[javax.swing.table.TableModel]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    preferredScrollableViewportSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rowHeight: Opt[Binding[Int]] = UnsetParam,
    rowMargin: Opt[Binding[Int]] = UnsetParam,
    rowSelectionAllowed: Opt[Binding[Boolean]] = UnsetParam,
    rowSorter: Opt[Binding[javax.swing.RowSorter[_ <: javax.swing.table.TableModel] | Null]] = UnsetParam,
    selectionBackground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    selectionForeground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    selectionModel: Opt[Binding[javax.swing.ListSelectionModel]] = UnsetParam,
    showHorizontalLines: Opt[Binding[Boolean]] = UnsetParam,
    showVerticalLines: Opt[Binding[Boolean]] = UnsetParam,
    surrendersFocusOnKeystroke: Opt[Binding[Boolean]] = UnsetParam,
    tableHeader: Opt[Binding[javax.swing.table.JTableHeader | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    updateSelectionOnSort: Opt[Binding[Boolean]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[TableView] = {
    val res = uninitialized()
    TableView.init(res)
    ifSet(UI, TableView.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoCreateColumnsFromModel, TableView.ops.autoCreateColumnsFromModel(res) := _)
    ifSet(autoCreateRowSorter, TableView.ops.autoCreateRowSorter(res) := _)
    ifSet(autoResizeMode, TableView.ops.autoResizeMode(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(cellEditor, TableView.ops.cellEditor(res) := _)
    ifSet(cellSelectionEnabled, TableView.ops.cellSelectionEnabled(res) := _)
    ifSet(columnModel, TableView.ops.columnModel(res) := _)
    ifSet(columnSelectionAllowed, TableView.ops.columnSelectionAllowed(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(dragEnabled, TableView.ops.dragEnabled(res) := _)
    ifSet(dropMode, TableView.ops.dropMode(res) := _)
    ifSet(editingColumn, TableView.ops.editingColumn(res) := _)
    ifSet(editingRow, TableView.ops.editingRow(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(fillsViewportHeight, TableView.ops.fillsViewportHeight(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(gridColor, TableView.ops.gridColor(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(intercellSpacing, TableView.ops.intercellSpacing(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(model, TableView.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(preferredScrollableViewportSize, TableView.ops.preferredScrollableViewportSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rowHeight, TableView.ops.rowHeight(res) := _)
    ifSet(rowMargin, TableView.ops.rowMargin(res) := _)
    ifSet(rowSelectionAllowed, TableView.ops.rowSelectionAllowed(res) := _)
    ifSet(rowSorter, TableView.ops.rowSorter(res) := _)
    ifSet(selectionBackground, TableView.ops.selectionBackground(res) := _)
    ifSet(selectionForeground, TableView.ops.selectionForeground(res) := _)
    ifSet(selectionModel, TableView.ops.selectionModel(res) := _)
    ifSet(showHorizontalLines, TableView.ops.showHorizontalLines(res) := _)
    ifSet(showVerticalLines, TableView.ops.showVerticalLines(res) := _)
    ifSet(surrendersFocusOnKeystroke, TableView.ops.surrendersFocusOnKeystroke(res) := _)
    ifSet(tableHeader, TableView.ops.tableHeader(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(updateSelectionOnSort, TableView.ops.updateSelectionOnSort(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
  
}