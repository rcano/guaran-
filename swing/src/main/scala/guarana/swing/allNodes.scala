//AUTOGENERATED FILE, DO NOT MODIFY

package guarana.swing
import language.implicitConversions
import java.awt.{Component => _, TextComponent => _, _}
import java.awt.event._
import javax.swing._
import javax.swing.event._
import guarana.swing.util._
import scala.util.chaining._

opaque type Node  = java.awt.Container
object Node extends VarsMap {
  val Background = SwingVar[Node, java.awt.Color | Null]("background", _.getBackground, _.setBackground(_))
  val Bounds = SwingVar[Node, Bounds]("bounds", _.getBounds.nn, _.setBounds(_))
  val ComponentOrientation = SwingVar[Node, java.awt.ComponentOrientation]("componentOrientation", _.getComponentOrientation.nn, _.setComponentOrientation(_))
  val Cursor = SwingVar[Node, java.awt.Cursor | Null]("cursor", _.getCursor, _.setCursor(_))
  val Enabled = SwingVar[Node, Boolean]("enabled", _.isEnabled, _.setEnabled(_))
  val Focusable = SwingVar[Node, Boolean]("focusable", _.isFocusable, _.setFocusable(_))
  private val FocusedMut = Var[Boolean]("focusedMut", false)
  val Font = SwingVar[Node, java.awt.Font | Null]("font", _.getFont, _.setFont(_))
  val Foreground = SwingVar[Node, java.awt.Color | Null]("foreground", _.getForeground, _.setForeground(_))
  val MaxSize = SwingVar[Node, (Double, Double) | Null]("maxSize", {n => val d = n.getMaximumSize; if (d != null) (d.getWidth, d.getHeight) else null}, {(n, d) => n.setMaximumSize(if (d == null) null else java.awt.Dimension(d._1.toInt, d._2.toInt))})
  val MinSize = SwingVar[Node, (Double, Double) | Null]("minSize", {n => val d = n.getMinimumSize; if (d != null) (d.getWidth, d.getHeight) else null}, {(n, d) => n.setMinimumSize(if (d == null) null else java.awt.Dimension(d._1.toInt, d._2.toInt))})
  private val MouseLocationMut = Var[(Int, Int)]("mouseLocationMut", (0, 0))
  val PrefSize = SwingVar[Node, (Double, Double) | Null]("prefSize", {n => val d = n.getPreferredSize; if (d != null) (d.getWidth, d.getHeight) else null}, {(n, d) => n.setPreferredSize(if (d == null) null else java.awt.Dimension(d._1.toInt, d._2.toInt))})
  val Visible = SwingVar[Node, Boolean]("visible", _.isVisible, _.setVisible(_))

  val FocusEvents = Emitter[(FocusEvent, Boolean)]()

  extension ops on (v: Node) {
    def background = Node.Background.forInstance(v)
    def bounds = Node.Bounds.forInstance(v)
    def componentOrientation = Node.ComponentOrientation.forInstance(v)
    def cursor = Node.Cursor.forInstance(v)
    def enabled = Node.Enabled.forInstance(v)
    def focusable = Node.Focusable.forInstance(v)
    def focusedMut = Node.FocusedMut.forInstance(v)
    def font = Node.Font.forInstance(v)
    def foreground = Node.Foreground.forInstance(v)
    def maxSize = Node.MaxSize.forInstance(v)
    def minSize = Node.MinSize.forInstance(v)
    def mouseLocationMut = Node.MouseLocationMut.forInstance(v)
    def prefSize = Node.PrefSize.forInstance(v)
    def visible = Node.Visible.forInstance(v)

    def focusEvents = Node.FocusEvents.forInstance(v)

    def focused = Node.FocusedMut.asObsValIn(v)
    def mouseLocation = Node.MouseLocationMut.asObsValIn(v)
    def alignmentX = v.getAlignmentX
    def alignmentY = v.getAlignmentY
    def insets = v.getInsets
    def location = v.getLocation
    def size = v.getSize
    def location(x: Int, y: Int) = v.setLocation(x, y)
    def size(x: Int, y: Int) = v.setSize(x, y)
    def children: Seq[Node] = (0 until v.getComponentCount).map(i => v.getComponent(i).asInstanceOf[Container])
    def unwrap: java.awt.Container = v
  }

  def apply(v: java.awt.Container) = v.asInstanceOf[Node]

  def init(v: Node): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    
    v.addPropertyChangeListener(varsPropertyListener(v))
    v addMouseMotionListener new java.awt.event.MouseMotionListener {
      def mouseDragged(evt: java.awt.event.MouseEvent | Null) = ()
      def mouseMoved(evt: java.awt.event.MouseEvent | Null) = sc.update {
        val nnEvt = evt.nn
        Node.MouseLocationMut.forInstance(v) := (nnEvt.getX, nnEvt.getY)
      }
    }
    v addFocusListener new FocusListener {
      def focusGained(evt: FocusEvent | UncheckedNull) = sc.update {
        Node.FocusedMut.forInstance(v) := true 
        summon[Emitter.Context].emit(v.focusEvents, (evt.nn -> true))
      }
      def focusLost(evt: FocusEvent | UncheckedNull) = sc.update {
        Node.FocusedMut.forInstance(v) := false
        summon[Emitter.Context].emit(v.focusEvents, (evt.nn -> false))
      }
    }
    
  }
  def uninitialized(): Node = {
    val res = java.awt.Container().asInstanceOf[Node]
    
    res
  }
  
  def apply(
    
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Node] = {
    val res = uninitialized()
    Node.init(res)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Component <: Node = javax.swing.JComponent & Node
object Component extends VarsMap {
  val ActionMap = SwingVar[Component, javax.swing.ActionMap]("actionMap", _.getActionMap.nn, _.setActionMap(_))
  val AlignmentX = SwingVar[Component, Float]("alignmentX", _.getAlignmentX, _.setAlignmentX(_))
  val AlignmentY = SwingVar[Component, Float]("alignmentY", _.getAlignmentY, _.setAlignmentY(_))
  val Autoscrolls = SwingVar[Component, Boolean]("autoscrolls", _.getAutoscrolls, _.setAutoscrolls(_))
  val Border = SwingVar[Component, javax.swing.border.Border | Null]("border", _.getBorder, _.setBorder(_))
  val ComponentPopupMenu = SwingVar[Component, javax.swing.JPopupMenu | Null]("componentPopupMenu", _.getComponentPopupMenu, _.setComponentPopupMenu(_))
  val DebugGraphicsOptions = SwingVar[Component, Int]("debugGraphicsOptions", _.getDebugGraphicsOptions, _.setDebugGraphicsOptions(_))
  val DoubleBuffered = SwingVar[Component, Boolean]("doubleBuffered", _.isDoubleBuffered, _.setDoubleBuffered(_))
  val InheritsPopupMenu = SwingVar[Component, Boolean]("inheritsPopupMenu", _.getInheritsPopupMenu, _.setInheritsPopupMenu(_))
  val InputVerifier = SwingVar[Component, javax.swing.InputVerifier | Null]("inputVerifier", _.getInputVerifier, _.setInputVerifier(_))
  val Opaque = SwingVar[Component, Boolean]("opaque", _.isOpaque, _.setOpaque(_))
  val RequestFocusEnabled = SwingVar[Component, Boolean]("requestFocusEnabled", _.isRequestFocusEnabled, _.setRequestFocusEnabled(_))
  val ToolTipText = SwingVar[Component, String | Null]("toolTipText", _.getToolTipText, _.setToolTipText(_))
  val TransferHandler = SwingVar[Component, javax.swing.TransferHandler | Null]("transferHandler", _.getTransferHandler, _.setTransferHandler(_))
  val VerifyInputWhenFocusTarget = SwingVar[Component, Boolean]("verifyInputWhenFocusTarget", _.getVerifyInputWhenFocusTarget, _.setVerifyInputWhenFocusTarget(_))

  

  extension ops on (v: Component) {
    def actionMap = Component.ActionMap.forInstance(v)
    def alignmentX = Component.AlignmentX.forInstance(v)
    def alignmentY = Component.AlignmentY.forInstance(v)
    def autoscrolls = Component.Autoscrolls.forInstance(v)
    def border = Component.Border.forInstance(v)
    def componentPopupMenu = Component.ComponentPopupMenu.forInstance(v)
    def debugGraphicsOptions = Component.DebugGraphicsOptions.forInstance(v)
    def doubleBuffered = Component.DoubleBuffered.forInstance(v)
    def inheritsPopupMenu = Component.InheritsPopupMenu.forInstance(v)
    def inputVerifier = Component.InputVerifier.forInstance(v)
    def opaque = Component.Opaque.forInstance(v)
    def requestFocusEnabled = Component.RequestFocusEnabled.forInstance(v)
    def toolTipText = Component.ToolTipText.forInstance(v)
    def transferHandler = Component.TransferHandler.forInstance(v)
    def verifyInputWhenFocusTarget = Component.VerifyInputWhenFocusTarget.forInstance(v)

    

    def UI = v.getUI
    def UIClassID = v.getUIClassID
    def ancestorListeners = v.getAncestorListeners
    def inputMap = v.getInputMap
    def optimizedDrawingEnabled = v.isOptimizedDrawingEnabled
    def paintingForPrint = v.isPaintingForPrint
    def paintingTile = v.isPaintingTile
    def registeredKeyStrokes = v.getRegisteredKeyStrokes
    def rootPane = v.getRootPane
    def topLevelAncestor = v.getTopLevelAncestor
    def vetoableChangeListeners = v.getVetoableChangeListeners
    def visibleRect = v.getVisibleRect
    def unwrap: javax.swing.JComponent = v
  }

  def apply(v: javax.swing.JComponent) = v.asInstanceOf[Component]

  def init(v: Component): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Node.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  
}

opaque type Window <: Node = java.awt.Window & Node
object Window extends VarsMap {
  val AlwaysOnTop = SwingVar[Window, Boolean]("alwaysOnTop", _.isAlwaysOnTop, _.setAlwaysOnTop(_))
  val AutoRequestFocus = SwingVar[Window, Boolean]("autoRequestFocus", _.isAutoRequestFocus, _.setAutoRequestFocus(_))
  val FocusCycleRoot = SwingVar[Window, Boolean]("focusCycleRoot", _.isFocusCycleRoot, _.setFocusCycleRoot(_))
  val FocusableWindowState = SwingVar[Window, Boolean]("focusableWindowState", _.getFocusableWindowState, _.setFocusableWindowState(_))
  val IconImages = SwingVar[Window, java.util.List[_ <: java.awt.Image] | Null]("iconImages", _.getIconImages, _.setIconImages(_))
  val LocationByPlatform = SwingVar[Window, Boolean]("locationByPlatform", _.isLocationByPlatform, _.setLocationByPlatform(_))
  val ModalExclusionType = SwingVar[Window, java.awt.Dialog.ModalExclusionType]("modalExclusionType", _.getModalExclusionType.nn, _.setModalExclusionType(_))
  val Opacity = SwingVar[Window, Float]("opacity", _.getOpacity, _.setOpacity(_))
  val Root = SwingVar[Window, Node]("root", c => Node(c.getComponent(0).asInstanceOf[Container]), (w, n) => w.add(n, 0))
  val Shape = SwingVar[Window, java.awt.Shape | Null]("shape", _.getShape, _.setShape(_))
  val Tpe = SwingVar[Window, java.awt.Window.Type]("tpe", _.getType.nn, _.setType(_))

  

  extension ops on (v: Window) {
    def alwaysOnTop = Window.AlwaysOnTop.forInstance(v)
    def autoRequestFocus = Window.AutoRequestFocus.forInstance(v)
    def focusCycleRoot = Window.FocusCycleRoot.forInstance(v)
    def focusableWindowState = Window.FocusableWindowState.forInstance(v)
    def iconImages = Window.IconImages.forInstance(v)
    def locationByPlatform = Window.LocationByPlatform.forInstance(v)
    def modalExclusionType = Window.ModalExclusionType.forInstance(v)
    def opacity = Window.Opacity.forInstance(v)
    def root = Window.Root.forInstance(v)
    def shape = Window.Shape.forInstance(v)
    def tpe = Window.Tpe.forInstance(v)

    

    def accessibleContext = v.getAccessibleContext
    def active = v.isActive
    def alwaysOnTopSupported = v.isAlwaysOnTopSupported
    def bufferStrategy = v.getBufferStrategy
    def focusCycleRootAncestor = v.getFocusCycleRootAncestor
    def focusOwner = v.getFocusOwner
    def focusableWindow = v.isFocusableWindow
    def focused = v.isFocused
    def inputContext = v.getInputContext
    def locale = v.getLocale
    def mostRecentFocusOwner = v.getMostRecentFocusOwner
    def opaque = v.isOpaque
    def ownedWindows = v.getOwnedWindows
    def owner = v.getOwner
    def pack() = v.pack()
    def showing = v.isShowing
    def toFront() = v.toFront()
    def toBack() = v.toBack()
    def toolkit = v.getToolkit
    def validateRoot = v.isValidateRoot
    def warningString = v.getWarningString
    def windowFocusListeners = v.getWindowFocusListeners
    def windowListeners = v.getWindowListeners
    def windowStateListeners = v.getWindowStateListeners
    def unwrap: java.awt.Window = v
  }

  def apply(v: java.awt.Window) = v.asInstanceOf[Window]

  def init(v: Window): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Node.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(parent: java.awt.Window | Null = null, gc: GraphicsConfiguration | Null = null): Window = {
    val res = java.awt.Window(parent, gc).asInstanceOf[Window]
    
    res
  }
  
  def apply(
    parent: java.awt.Window | Null = null, gc: GraphicsConfiguration | Null = null,
    alwaysOnTop: Opt[Binding[Boolean]] = UnsetParam,
    autoRequestFocus: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusCycleRoot: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusableWindowState: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    iconImages: Opt[Binding[java.util.List[_ <: java.awt.Image] | Null]] = UnsetParam,
    locationByPlatform: Opt[Binding[Boolean]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    modalExclusionType: Opt[Binding[java.awt.Dialog.ModalExclusionType]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opacity: Opt[Binding[Float]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    root: Opt[Binding[Node]] = UnsetParam,
    shape: Opt[Binding[java.awt.Shape | Null]] = UnsetParam,
    tpe: Opt[Binding[java.awt.Window.Type]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Window] = {
    val res = uninitialized()
    Window.init(res)
    ifSet(alwaysOnTop, Window.ops.alwaysOnTop(res) := _)
    ifSet(autoRequestFocus, Window.ops.autoRequestFocus(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusCycleRoot, Window.ops.focusCycleRoot(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusableWindowState, Window.ops.focusableWindowState(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(iconImages, Window.ops.iconImages(res) := _)
    ifSet(locationByPlatform, Window.ops.locationByPlatform(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(modalExclusionType, Window.ops.modalExclusionType(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opacity, Window.ops.opacity(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(root, Window.ops.root(res) := _)
    ifSet(shape, Window.ops.shape(res) := _)
    ifSet(tpe, Window.ops.tpe(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Frame <: Window = java.awt.Frame & Window
object Frame extends VarsMap {
  val ExtendedState = SwingVar[Frame, Int]("extendedState", _.getExtendedState, _.setExtendedState(_))
  val IconImage = SwingVar[Frame, java.awt.Image | Null]("iconImage", _.getIconImage, _.setIconImage(_))
  val MaximizedBounds = SwingVar[Frame, Bounds | Null]("maximizedBounds", _.getMaximizedBounds, _.setMaximizedBounds(_))
  val MenuBar = SwingVar[Frame, java.awt.MenuBar | Null]("menuBar", _.getMenuBar, _.setMenuBar(_))
  val Resizable = SwingVar[Frame, Boolean]("resizable", _.isResizable, _.setResizable(_))
  val State = SwingVar[Frame, Int]("state", _.getState, _.setState(_))
  val Title = SwingVar[Frame, java.lang.String | Null]("title", _.getTitle, _.setTitle(_))
  val Undecorated = SwingVar[Frame, Boolean]("undecorated", _.isUndecorated, _.setUndecorated(_))

  

  extension ops on (v: Frame) {
    def extendedState = Frame.ExtendedState.forInstance(v)
    def iconImage = Frame.IconImage.forInstance(v)
    def maximizedBounds = Frame.MaximizedBounds.forInstance(v)
    def menuBar = Frame.MenuBar.forInstance(v)
    def resizable = Frame.Resizable.forInstance(v)
    def state = Frame.State.forInstance(v)
    def title = Frame.Title.forInstance(v)
    def undecorated = Frame.Undecorated.forInstance(v)

    

    def cursorType = v.getCursorType
    def unwrap: java.awt.Frame = v
  }

  def apply(v: java.awt.Frame) = v.asInstanceOf[Frame]

  def init(v: Frame): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Window.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(gc: GraphicsConfiguration | Null = null): Frame = {
    val res = java.awt.Frame(gc).asInstanceOf[Frame]
    
    res
  }
  
  def apply(
    gc: GraphicsConfiguration | Null = null,
    alwaysOnTop: Opt[Binding[Boolean]] = UnsetParam,
    autoRequestFocus: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    extendedState: Opt[Binding[Int]] = UnsetParam,
    focusCycleRoot: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusableWindowState: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    iconImage: Opt[Binding[java.awt.Image | Null]] = UnsetParam,
    iconImages: Opt[Binding[java.util.List[_ <: java.awt.Image] | Null]] = UnsetParam,
    locationByPlatform: Opt[Binding[Boolean]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    maximizedBounds: Opt[Binding[Bounds | Null]] = UnsetParam,
    menuBar: Opt[Binding[java.awt.MenuBar | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    modalExclusionType: Opt[Binding[java.awt.Dialog.ModalExclusionType]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opacity: Opt[Binding[Float]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    resizable: Opt[Binding[Boolean]] = UnsetParam,
    root: Opt[Binding[Node]] = UnsetParam,
    shape: Opt[Binding[java.awt.Shape | Null]] = UnsetParam,
    state: Opt[Binding[Int]] = UnsetParam,
    title: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    tpe: Opt[Binding[java.awt.Window.Type]] = UnsetParam,
    undecorated: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Frame] = {
    val res = uninitialized()
    Frame.init(res)
    ifSet(alwaysOnTop, Window.ops.alwaysOnTop(res) := _)
    ifSet(autoRequestFocus, Window.ops.autoRequestFocus(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(extendedState, Frame.ops.extendedState(res) := _)
    ifSet(focusCycleRoot, Window.ops.focusCycleRoot(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusableWindowState, Window.ops.focusableWindowState(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(iconImage, Frame.ops.iconImage(res) := _)
    ifSet(iconImages, Window.ops.iconImages(res) := _)
    ifSet(locationByPlatform, Window.ops.locationByPlatform(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(maximizedBounds, Frame.ops.maximizedBounds(res) := _)
    ifSet(menuBar, Frame.ops.menuBar(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(modalExclusionType, Window.ops.modalExclusionType(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opacity, Window.ops.opacity(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(resizable, Frame.ops.resizable(res) := _)
    ifSet(root, Window.ops.root(res) := _)
    ifSet(shape, Window.ops.shape(res) := _)
    ifSet(state, Frame.ops.state(res) := _)
    ifSet(title, Frame.ops.title(res) := _)
    ifSet(tpe, Window.ops.tpe(res) := _)
    ifSet(undecorated, Frame.ops.undecorated(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Pane <: Component = javax.swing.JPanel & Component
object Pane extends VarsMap {
  val UI = SwingVar[Pane, javax.swing.plaf.PanelUI]("UI", _.getUI.nn, _.setUI(_))

  

  extension ops on (v: Pane) {
    def UI = Pane.UI.forInstance(v)

    

    
    def unwrap: javax.swing.JPanel = v
  }

  def apply(v: javax.swing.JPanel) = v.asInstanceOf[Pane]

  def init(v: Pane): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): Pane = {
    val res = javax.swing.JPanel().asInstanceOf[Pane]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.PanelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Pane] = {
    val res = uninitialized()
    Pane.init(res)
    ifSet(UI, Pane.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type AbsolutePositioningPane <: Pane = javax.swing.JPanel & Pane
object AbsolutePositioningPane extends VarsMap {
  val Nodes = SwingVar[AbsolutePositioningPane, Seq[Node]]("nodes", c => (0 until c.getComponentCount).map(c.getComponent(_).asInstanceOf[Node]), (p, children) => { p.removeAll(); children foreach (n => p.add(n)) })

  

  extension ops on (v: AbsolutePositioningPane) {
    def nodes = AbsolutePositioningPane.Nodes.forInstance(v)

    

    
    def unwrap: javax.swing.JPanel = v
  }

  def apply(v: javax.swing.JPanel) = v.asInstanceOf[AbsolutePositioningPane]

  def init(v: AbsolutePositioningPane): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Pane.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): AbsolutePositioningPane = {
    val res = javax.swing.JPanel().asInstanceOf[AbsolutePositioningPane]
    res.asInstanceOf[JPanel].setLayout(null)
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.PanelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    nodes: Opt[Binding[Seq[Node]]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[AbsolutePositioningPane] = {
    val res = uninitialized()
    AbsolutePositioningPane.init(res)
    ifSet(UI, Pane.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(nodes, AbsolutePositioningPane.ops.nodes(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type BorderPane <: Pane = javax.swing.JPanel & Pane
object BorderPane extends VarsMap {
  val Bottom = SwingVar[BorderPane, Node | Null]("bottom", c => c.getLayout.asInstanceOf[BorderLayout].getLayoutComponent(BorderLayout.SOUTH).asInstanceOf[Node | Null], (p, n) => { p.add(if (n == null) null else n, BorderLayout.SOUTH) })
  val Center = SwingVar[BorderPane, Node | Null]("center", c => c.getLayout.asInstanceOf[BorderLayout].getLayoutComponent(BorderLayout.CENTER).asInstanceOf[Node | Null], (p, n) => { p.add(if (n == null) null else n, BorderLayout.CENTER) })
  val Hgap = SwingVar[BorderPane, Double]("hgap", c => c.getLayout.asInstanceOf[BorderLayout].getHgap, (p, g) => p.getLayout.asInstanceOf[BorderLayout].setHgap(g.toInt))
  val Left = SwingVar[BorderPane, Node | Null]("left", c => c.getLayout.asInstanceOf[BorderLayout].getLayoutComponent(BorderLayout.WEST).asInstanceOf[Node | Null], (p, n) => { p.add(if (n == null) null else n, BorderLayout.WEST) })
  val Right = SwingVar[BorderPane, Node | Null]("right", c => c.getLayout.asInstanceOf[BorderLayout].getLayoutComponent(BorderLayout.EAST).asInstanceOf[Node | Null], (p, n) => { p.add(if (n == null) null else n, BorderLayout.EAST) })
  val Top = SwingVar[BorderPane, Node | Null]("top", c => c.getLayout.asInstanceOf[BorderLayout].getLayoutComponent(BorderLayout.NORTH).asInstanceOf[Node | Null], (p, n) => { p.add(if (n == null) null else n, BorderLayout.NORTH) })
  val Vgap = SwingVar[BorderPane, Double]("vgap", c => c.getLayout.asInstanceOf[BorderLayout].getVgap, (p, g) => p.getLayout.asInstanceOf[BorderLayout].setVgap(g.toInt))

  

  extension ops on (v: BorderPane) {
    def bottom = BorderPane.Bottom.forInstance(v)
    def center = BorderPane.Center.forInstance(v)
    def hgap = BorderPane.Hgap.forInstance(v)
    def left = BorderPane.Left.forInstance(v)
    def right = BorderPane.Right.forInstance(v)
    def top = BorderPane.Top.forInstance(v)
    def vgap = BorderPane.Vgap.forInstance(v)

    

    
    def unwrap: javax.swing.JPanel = v
  }

  def apply(v: javax.swing.JPanel) = v.asInstanceOf[BorderPane]

  def init(v: BorderPane): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Pane.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): BorderPane = {
    val res = javax.swing.JPanel().asInstanceOf[BorderPane]
    res.asInstanceOf[JPanel].setLayout(BorderLayout())
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.PanelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bottom: Opt[Binding[Node | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    center: Opt[Binding[Node | Null]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    hgap: Opt[Binding[Double]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    left: Opt[Binding[Node | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    right: Opt[Binding[Node | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    top: Opt[Binding[Node | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    vgap: Opt[Binding[Double]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[BorderPane] = {
    val res = uninitialized()
    BorderPane.init(res)
    ifSet(UI, Pane.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bottom, BorderPane.ops.bottom(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(center, BorderPane.ops.center(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(hgap, BorderPane.ops.hgap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(left, BorderPane.ops.left(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(right, BorderPane.ops.right(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(top, BorderPane.ops.top(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(vgap, BorderPane.ops.vgap(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type GridPane <: Pane = javax.swing.JPanel & Pane
object GridPane extends VarsMap {
  val AutoCreateContainerGaps = SwingVar[GridPane, Boolean]("autoCreateContainerGaps", _.getLayout.asInstanceOf[GroupLayout].getAutoCreateContainerGaps(), _.getLayout.asInstanceOf[GroupLayout].setAutoCreateContainerGaps(_))
  val Hgap = Var[Double]("hgap", 0.0)
  val LayoutVar = SwingVar[GridPane, Unit]("layoutVar", _ => (), (_, _) => ())
  val Rows = Var[Seq[Seq[Node]]]("rows", Seq.empty)
  val Vgap = Var[Double]("vgap", 0.0)

  

  extension ops on (v: GridPane) {
    def autoCreateContainerGaps = GridPane.AutoCreateContainerGaps.forInstance(v)
    def hgap = GridPane.Hgap.forInstance(v)
    def layoutVar = GridPane.LayoutVar.forInstance(v)
    def rows = GridPane.Rows.forInstance(v)
    def vgap = GridPane.Vgap.forInstance(v)

    

    
    def unwrap: javax.swing.JPanel = v
  }

  def apply(v: javax.swing.JPanel) = v.asInstanceOf[GridPane]

  def init(v: GridPane): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Pane.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    sc.update(LayoutVar.forInstance(v) := Binding.dyn {
    val rows = v.rows()
    val hgap = v.hgap().toInt
    val vgap = v.vgap().toInt
    
    val layout = v.getLayout.asInstanceOf[GroupLayout]
    val hgroup = layout.createSequentialGroup().nn
    val vgroup = layout.createSequentialGroup().nn
    
    val hSeqGroups = collection.mutable.Map.empty[Int, GroupLayout#ParallelGroup]
    val vSeqGroups = collection.mutable.Map.empty[Int, GroupLayout#ParallelGroup]
    
    val rowSize = rows.size
    
    for {
      (row, rowIdx) <- rows.zipWithIndex
      colSize = row.length
      (node, colIdx) <- row.zipWithIndex
    } {
      hSeqGroups
        .getOrElseUpdate(colIdx, layout.createParallelGroup().nn.tap { g => 
          hgroup.addGroup(g)
          if (hgap > 0 && colIdx < colSize - 1) hgroup.addGap(hgap)
        })
        .addComponent(node)
    
      vSeqGroups
        .getOrElseUpdate(rowIdx, layout.createBaselineGroup(true, false).nn.tap { g => 
          vgroup.addGroup(g)
          if (vgap > 0 && rowIdx < rowSize - 1) vgroup.addGap(vgap)
        })
        .addComponent(node)
    }
    
    layout.setHorizontalGroup(hgroup)
    layout.setVerticalGroup(vgroup)
    })
    
  }
  def uninitialized(): GridPane = {
    val res = javax.swing.JPanel().asInstanceOf[GridPane]
    res.asInstanceOf[JPanel].setLayout(GroupLayout(res))
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.PanelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoCreateContainerGaps: Opt[Binding[Boolean]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    hgap: Opt[Binding[Double]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    layoutVar: Opt[Binding[Unit]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rows: Opt[Binding[Seq[Seq[Node]]]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    vgap: Opt[Binding[Double]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[GridPane] = {
    val res = uninitialized()
    GridPane.init(res)
    ifSet(UI, Pane.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoCreateContainerGaps, GridPane.ops.autoCreateContainerGaps(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(hgap, GridPane.ops.hgap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(layoutVar, GridPane.ops.layoutVar(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rows, GridPane.ops.rows(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(vgap, GridPane.ops.vgap(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Hbox <: Pane = javax.swing.JPanel & Pane
object Hbox extends VarsMap {
  val Nodes = SwingVar[Hbox, Seq[Node]]("nodes", c => (0 until c.getComponentCount).map(c.getComponent(_).asInstanceOf[Node]), (p, children) => { p.removeAll(); children foreach (n => p.add(n)) })

  

  extension ops on (v: Hbox) {
    def nodes = Hbox.Nodes.forInstance(v)

    

    
    def unwrap: javax.swing.JPanel = v
  }

  def apply(v: javax.swing.JPanel) = v.asInstanceOf[Hbox]

  def init(v: Hbox): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Pane.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): Hbox = {
    val res = javax.swing.JPanel().asInstanceOf[Hbox]
    res.asInstanceOf[JPanel].setLayout(BoxLayout(res, BoxLayout.X_AXIS))
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.PanelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    nodes: Opt[Binding[Seq[Node]]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Hbox] = {
    val res = uninitialized()
    Hbox.init(res)
    ifSet(UI, Pane.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(nodes, Hbox.ops.nodes(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Vbox <: Pane = javax.swing.JPanel & Pane
object Vbox extends VarsMap {
  val Nodes = SwingVar[Vbox, Seq[Node]]("nodes", c => (0 until c.getComponentCount).map(c.getComponent(_).asInstanceOf[Node]), (p, children) => { p.removeAll(); children foreach (n => p.add(n)) })

  

  extension ops on (v: Vbox) {
    def nodes = Vbox.Nodes.forInstance(v)

    

    
    def unwrap: javax.swing.JPanel = v
  }

  def apply(v: javax.swing.JPanel) = v.asInstanceOf[Vbox]

  def init(v: Vbox): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Pane.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): Vbox = {
    val res = javax.swing.JPanel().asInstanceOf[Vbox]
    res.asInstanceOf[JPanel].setLayout(BoxLayout(res, BoxLayout.Y_AXIS))
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.PanelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    nodes: Opt[Binding[Seq[Node]]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Vbox] = {
    val res = uninitialized()
    Vbox.init(res)
    ifSet(UI, Pane.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(nodes, Vbox.ops.nodes(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type TextComponent <: Component = javax.swing.text.JTextComponent & Component
object TextComponent extends VarsMap {
  val UI = SwingVar[TextComponent, javax.swing.plaf.TextUI]("UI", _.getUI.nn, _.setUI(_))
  val Caret = SwingVar[TextComponent, javax.swing.text.Caret]("caret", _.getCaret.nn, _.setCaret(_))
  val CaretColor = SwingVar[TextComponent, java.awt.Color | Null]("caretColor", _.getCaretColor, _.setCaretColor(_))
  val DisabledTextColor = SwingVar[TextComponent, java.awt.Color | Null]("disabledTextColor", _.getDisabledTextColor, _.setDisabledTextColor(_))
  val Document = SwingVar[TextComponent, javax.swing.text.Document]("document", _.getDocument.nn, _.setDocument(_))
  val DragEnabled = SwingVar[TextComponent, Boolean]("dragEnabled", _.getDragEnabled, _.setDragEnabled(_))
  val DropMode = SwingVar[TextComponent, javax.swing.DropMode | Null]("dropMode", _.getDropMode, _.setDropMode(_))
  val Editable = SwingVar[TextComponent, Boolean]("editable", _.isEditable, _.setEditable(_))
  val FocusAccelerator = SwingVar[TextComponent, Char]("focusAccelerator", _.getFocusAccelerator, _.setFocusAccelerator(_))
  val Highlighter = SwingVar[TextComponent, javax.swing.text.Highlighter | Null]("highlighter", _.getHighlighter, _.setHighlighter(_))
  val Keymap = SwingVar[TextComponent, javax.swing.text.Keymap | Null]("keymap", _.getKeymap, _.setKeymap(_))
  val Margin = SwingVar[TextComponent, java.awt.Insets | Null]("margin", _.getMargin, _.setMargin(_))
  val NavigationFilter = SwingVar[TextComponent, javax.swing.text.NavigationFilter | Null]("navigationFilter", _.getNavigationFilter, _.setNavigationFilter(_))
  val SelectedTextColor = SwingVar[TextComponent, java.awt.Color | Null]("selectedTextColor", _.getSelectedTextColor, _.setSelectedTextColor(_))
  val SelectionColor = SwingVar[TextComponent, java.awt.Color | Null]("selectionColor", _.getSelectionColor, _.setSelectionColor(_))

  

  extension ops on (v: TextComponent) {
    def UI = TextComponent.UI.forInstance(v)
    def caret = TextComponent.Caret.forInstance(v)
    def caretColor = TextComponent.CaretColor.forInstance(v)
    def disabledTextColor = TextComponent.DisabledTextColor.forInstance(v)
    def document = TextComponent.Document.forInstance(v)
    def dragEnabled = TextComponent.DragEnabled.forInstance(v)
    def dropMode = TextComponent.DropMode.forInstance(v)
    def editable = TextComponent.Editable.forInstance(v)
    def focusAccelerator = TextComponent.FocusAccelerator.forInstance(v)
    def highlighter = TextComponent.Highlighter.forInstance(v)
    def keymap = TextComponent.Keymap.forInstance(v)
    def margin = TextComponent.Margin.forInstance(v)
    def navigationFilter = TextComponent.NavigationFilter.forInstance(v)
    def selectedTextColor = TextComponent.SelectedTextColor.forInstance(v)
    def selectionColor = TextComponent.SelectionColor.forInstance(v)

    

    def actions = v.getActions
    def caretListeners = v.getCaretListeners
    def dropLocation = v.getDropLocation
    def preferredScrollableViewportSize = v.getPreferredScrollableViewportSize
    def scrollableTracksViewportHeight = v.getScrollableTracksViewportHeight
    def scrollableTracksViewportWidth = v.getScrollableTracksViewportWidth
    def selectedText = v.getSelectedText
    def text = v.getText
    def text_=(s: String) = v.setText(s)
    def unwrap: javax.swing.text.JTextComponent = v
  }

  def apply(v: javax.swing.text.JTextComponent) = v.asInstanceOf[TextComponent]

  def init(v: TextComponent): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    v.getDocument.addDocumentListener(new DocumentListener {
      def changedUpdate(evt: DocumentEvent | Null) = notifyChange()
      def insertUpdate(evt: DocumentEvent | Null) = notifyChange()
      def removeUpdate(evt: DocumentEvent | Null) = notifyChange()
      def notifyChange() = summon[Scenegraph].update(summon[VarContext].swingPropertyUpdated(ops.document(v), v.getDocument.nn))
    })
    
  }
  
}

opaque type TextArea <: TextComponent = javax.swing.JTextArea & TextComponent
object TextArea extends VarsMap {
  val Columns = SwingVar[TextArea, Int]("columns", _.getColumns, _.setColumns(_))
  val LineWrap = SwingVar[TextArea, Boolean]("lineWrap", _.getLineWrap, _.setLineWrap(_))
  val Rows = SwingVar[TextArea, Int]("rows", _.getRows, _.setRows(_))
  val TabSize = SwingVar[TextArea, Int]("tabSize", _.getTabSize, _.setTabSize(_))
  val WrapStyleWord = SwingVar[TextArea, Boolean]("wrapStyleWord", _.getWrapStyleWord, _.setWrapStyleWord(_))

  

  extension ops on (v: TextArea) {
    def columns = TextArea.Columns.forInstance(v)
    def lineWrap = TextArea.LineWrap.forInstance(v)
    def rows = TextArea.Rows.forInstance(v)
    def tabSize = TextArea.TabSize.forInstance(v)
    def wrapStyleWord = TextArea.WrapStyleWord.forInstance(v)

    

    def lineCount = v.getLineCount
    def unwrap: javax.swing.JTextArea = v
  }

  def apply(v: javax.swing.JTextArea) = v.asInstanceOf[TextArea]

  def init(v: TextArea): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    TextComponent.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): TextArea = {
    val res = javax.swing.JTextArea().asInstanceOf[TextArea]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.TextUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    caret: Opt[Binding[javax.swing.text.Caret]] = UnsetParam,
    caretColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    columns: Opt[Binding[Int]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledTextColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    document: Opt[Binding[javax.swing.text.Document]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    dragEnabled: Opt[Binding[Boolean]] = UnsetParam,
    dropMode: Opt[Binding[javax.swing.DropMode | Null]] = UnsetParam,
    editable: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusAccelerator: Opt[Binding[Char]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    highlighter: Opt[Binding[javax.swing.text.Highlighter | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    keymap: Opt[Binding[javax.swing.text.Keymap | Null]] = UnsetParam,
    lineWrap: Opt[Binding[Boolean]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    navigationFilter: Opt[Binding[javax.swing.text.NavigationFilter | Null]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rows: Opt[Binding[Int]] = UnsetParam,
    selectedTextColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    selectionColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    tabSize: Opt[Binding[Int]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam,
    wrapStyleWord: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[TextArea] = {
    val res = uninitialized()
    TextArea.init(res)
    ifSet(UI, TextComponent.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(caret, TextComponent.ops.caret(res) := _)
    ifSet(caretColor, TextComponent.ops.caretColor(res) := _)
    ifSet(columns, TextArea.ops.columns(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledTextColor, TextComponent.ops.disabledTextColor(res) := _)
    ifSet(document, TextComponent.ops.document(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(dragEnabled, TextComponent.ops.dragEnabled(res) := _)
    ifSet(dropMode, TextComponent.ops.dropMode(res) := _)
    ifSet(editable, TextComponent.ops.editable(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusAccelerator, TextComponent.ops.focusAccelerator(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(highlighter, TextComponent.ops.highlighter(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(keymap, TextComponent.ops.keymap(res) := _)
    ifSet(lineWrap, TextArea.ops.lineWrap(res) := _)
    ifSet(margin, TextComponent.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(navigationFilter, TextComponent.ops.navigationFilter(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rows, TextArea.ops.rows(res) := _)
    ifSet(selectedTextColor, TextComponent.ops.selectedTextColor(res) := _)
    ifSet(selectionColor, TextComponent.ops.selectionColor(res) := _)
    ifSet(tabSize, TextArea.ops.tabSize(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    ifSet(wrapStyleWord, TextArea.ops.wrapStyleWord(res) := _)
    res
  }
}

opaque type TextField <: TextComponent = javax.swing.JTextField & TextComponent
object TextField extends VarsMap {
  val Action = SwingVar[TextField, javax.swing.Action | Null]("action", _.getAction, _.setAction(_))
  val Columns = SwingVar[TextField, Int]("columns", _.getColumns, _.setColumns(_))
  val HorizontalAlignment = SwingVar[TextField, Int]("horizontalAlignment", _.getHorizontalAlignment, _.setHorizontalAlignment(_))
  val ScrollOffset = SwingVar[TextField, Int]("scrollOffset", _.getScrollOffset, _.setScrollOffset(_))

  

  extension ops on (v: TextField) {
    def action = TextField.Action.forInstance(v)
    def columns = TextField.Columns.forInstance(v)
    def horizontalAlignment = TextField.HorizontalAlignment.forInstance(v)
    def scrollOffset = TextField.ScrollOffset.forInstance(v)

    

    def horizontalVisibility = v.getHorizontalVisibility
    def unwrap: javax.swing.JTextField = v
  }

  def apply(v: javax.swing.JTextField) = v.asInstanceOf[TextField]

  def init(v: TextField): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    TextComponent.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): TextField = {
    val res = javax.swing.JTextField().asInstanceOf[TextField]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.TextUI]] = UnsetParam,
    action: Opt[Binding[javax.swing.Action | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    caret: Opt[Binding[javax.swing.text.Caret]] = UnsetParam,
    caretColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    columns: Opt[Binding[Int]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledTextColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    document: Opt[Binding[javax.swing.text.Document]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    dragEnabled: Opt[Binding[Boolean]] = UnsetParam,
    dropMode: Opt[Binding[javax.swing.DropMode | Null]] = UnsetParam,
    editable: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusAccelerator: Opt[Binding[Char]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    highlighter: Opt[Binding[javax.swing.text.Highlighter | Null]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    keymap: Opt[Binding[javax.swing.text.Keymap | Null]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    navigationFilter: Opt[Binding[javax.swing.text.NavigationFilter | Null]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    scrollOffset: Opt[Binding[Int]] = UnsetParam,
    selectedTextColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    selectionColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[TextField] = {
    val res = uninitialized()
    TextField.init(res)
    ifSet(UI, TextComponent.ops.UI(res) := _)
    ifSet(action, TextField.ops.action(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(caret, TextComponent.ops.caret(res) := _)
    ifSet(caretColor, TextComponent.ops.caretColor(res) := _)
    ifSet(columns, TextField.ops.columns(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledTextColor, TextComponent.ops.disabledTextColor(res) := _)
    ifSet(document, TextComponent.ops.document(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(dragEnabled, TextComponent.ops.dragEnabled(res) := _)
    ifSet(dropMode, TextComponent.ops.dropMode(res) := _)
    ifSet(editable, TextComponent.ops.editable(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusAccelerator, TextComponent.ops.focusAccelerator(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(highlighter, TextComponent.ops.highlighter(res) := _)
    ifSet(horizontalAlignment, TextField.ops.horizontalAlignment(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(keymap, TextComponent.ops.keymap(res) := _)
    ifSet(margin, TextComponent.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(navigationFilter, TextComponent.ops.navigationFilter(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(scrollOffset, TextField.ops.scrollOffset(res) := _)
    ifSet(selectedTextColor, TextComponent.ops.selectedTextColor(res) := _)
    ifSet(selectionColor, TextComponent.ops.selectionColor(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type PasswordField <: TextField = javax.swing.JPasswordField & TextField
object PasswordField extends VarsMap {
  val EchoChar = SwingVar[PasswordField, Char]("echoChar", _.getEchoChar, _.setEchoChar(_))

  

  extension ops on (v: PasswordField) {
    def echoChar = PasswordField.EchoChar.forInstance(v)

    

    def password = v.getPassword
    def unwrap: javax.swing.JPasswordField = v
  }

  def apply(v: javax.swing.JPasswordField) = v.asInstanceOf[PasswordField]

  def init(v: PasswordField): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    TextField.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): PasswordField = {
    val res = javax.swing.JPasswordField().asInstanceOf[PasswordField]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.TextUI]] = UnsetParam,
    action: Opt[Binding[javax.swing.Action | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    caret: Opt[Binding[javax.swing.text.Caret]] = UnsetParam,
    caretColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    columns: Opt[Binding[Int]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledTextColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    document: Opt[Binding[javax.swing.text.Document]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    dragEnabled: Opt[Binding[Boolean]] = UnsetParam,
    dropMode: Opt[Binding[javax.swing.DropMode | Null]] = UnsetParam,
    echoChar: Opt[Binding[Char]] = UnsetParam,
    editable: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusAccelerator: Opt[Binding[Char]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    highlighter: Opt[Binding[javax.swing.text.Highlighter | Null]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    keymap: Opt[Binding[javax.swing.text.Keymap | Null]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    navigationFilter: Opt[Binding[javax.swing.text.NavigationFilter | Null]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    scrollOffset: Opt[Binding[Int]] = UnsetParam,
    selectedTextColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    selectionColor: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[PasswordField] = {
    val res = uninitialized()
    PasswordField.init(res)
    ifSet(UI, TextComponent.ops.UI(res) := _)
    ifSet(action, TextField.ops.action(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(caret, TextComponent.ops.caret(res) := _)
    ifSet(caretColor, TextComponent.ops.caretColor(res) := _)
    ifSet(columns, TextField.ops.columns(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledTextColor, TextComponent.ops.disabledTextColor(res) := _)
    ifSet(document, TextComponent.ops.document(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(dragEnabled, TextComponent.ops.dragEnabled(res) := _)
    ifSet(dropMode, TextComponent.ops.dropMode(res) := _)
    ifSet(echoChar, PasswordField.ops.echoChar(res) := _)
    ifSet(editable, TextComponent.ops.editable(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusAccelerator, TextComponent.ops.focusAccelerator(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(highlighter, TextComponent.ops.highlighter(res) := _)
    ifSet(horizontalAlignment, TextField.ops.horizontalAlignment(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(keymap, TextComponent.ops.keymap(res) := _)
    ifSet(margin, TextComponent.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(navigationFilter, TextComponent.ops.navigationFilter(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(scrollOffset, TextField.ops.scrollOffset(res) := _)
    ifSet(selectedTextColor, TextComponent.ops.selectedTextColor(res) := _)
    ifSet(selectionColor, TextComponent.ops.selectionColor(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Label <: Component = javax.swing.JLabel & Component
object Label extends VarsMap {
  val UI = SwingVar[Label, javax.swing.plaf.LabelUI]("UI", _.getUI.nn, _.setUI(_))
  val DisabledIcon = SwingVar[Label, javax.swing.Icon | Null]("disabledIcon", _.getDisabledIcon, _.setDisabledIcon(_))
  val DisplayedMnemonic = SwingVar[Label, Int]("displayedMnemonic", _.getDisplayedMnemonic, _.setDisplayedMnemonic(_))
  val DisplayedMnemonicIndex = SwingVar[Label, Int]("displayedMnemonicIndex", _.getDisplayedMnemonicIndex, _.setDisplayedMnemonicIndex(_))
  val HorizontalAlignment = SwingVar[Label, Int]("horizontalAlignment", _.getHorizontalAlignment, _.setHorizontalAlignment(_))
  val HorizontalTextPosition = SwingVar[Label, Int]("horizontalTextPosition", _.getHorizontalTextPosition, _.setHorizontalTextPosition(_))
  val Icon = SwingVar[Label, javax.swing.Icon | Null]("icon", _.getIcon, _.setIcon(_))
  val IconTextGap = SwingVar[Label, Double]("iconTextGap", _.getIconTextGap, (l, g) => l.setIconTextGap(g.toInt))
  val LabelFor = SwingVar[Label, java.awt.Component | Null]("labelFor", _.getLabelFor, _.setLabelFor(_))
  val Text = SwingVar[Label, java.lang.String | Null]("text", _.getText, _.setText(_))
  val VerticalAlignment = SwingVar[Label, Int]("verticalAlignment", _.getVerticalAlignment, _.setVerticalAlignment(_))
  val VerticalTextPosition = SwingVar[Label, Int]("verticalTextPosition", _.getVerticalTextPosition, _.setVerticalTextPosition(_))

  

  extension ops on (v: Label) {
    def UI = Label.UI.forInstance(v)
    def disabledIcon = Label.DisabledIcon.forInstance(v)
    def displayedMnemonic = Label.DisplayedMnemonic.forInstance(v)
    def displayedMnemonicIndex = Label.DisplayedMnemonicIndex.forInstance(v)
    def horizontalAlignment = Label.HorizontalAlignment.forInstance(v)
    def horizontalTextPosition = Label.HorizontalTextPosition.forInstance(v)
    def icon = Label.Icon.forInstance(v)
    def iconTextGap = Label.IconTextGap.forInstance(v)
    def labelFor = Label.LabelFor.forInstance(v)
    def text = Label.Text.forInstance(v)
    def verticalAlignment = Label.VerticalAlignment.forInstance(v)
    def verticalTextPosition = Label.VerticalTextPosition.forInstance(v)

    

    
    def unwrap: javax.swing.JLabel = v
  }

  def apply(v: javax.swing.JLabel) = v.asInstanceOf[Label]

  def init(v: Label): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): Label = {
    val res = javax.swing.JLabel().asInstanceOf[Label]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.LabelUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    displayedMnemonic: Opt[Binding[Int]] = UnsetParam,
    displayedMnemonicIndex: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    horizontalTextPosition: Opt[Binding[Int]] = UnsetParam,
    icon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    iconTextGap: Opt[Binding[Double]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    labelFor: Opt[Binding[java.awt.Component | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    text: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    verticalAlignment: Opt[Binding[Int]] = UnsetParam,
    verticalTextPosition: Opt[Binding[Int]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Label] = {
    val res = uninitialized()
    Label.init(res)
    ifSet(UI, Label.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledIcon, Label.ops.disabledIcon(res) := _)
    ifSet(displayedMnemonic, Label.ops.displayedMnemonic(res) := _)
    ifSet(displayedMnemonicIndex, Label.ops.displayedMnemonicIndex(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(horizontalAlignment, Label.ops.horizontalAlignment(res) := _)
    ifSet(horizontalTextPosition, Label.ops.horizontalTextPosition(res) := _)
    ifSet(icon, Label.ops.icon(res) := _)
    ifSet(iconTextGap, Label.ops.iconTextGap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(labelFor, Label.ops.labelFor(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(text, Label.ops.text(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(verticalAlignment, Label.ops.verticalAlignment(res) := _)
    ifSet(verticalTextPosition, Label.ops.verticalTextPosition(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type ButtonBase <: Component = javax.swing.AbstractButton & Component
object ButtonBase extends VarsMap {
  val UI = SwingVar[ButtonBase, javax.swing.plaf.ButtonUI]("UI", _.getUI.nn, _.setUI(_))
  val Action = SwingVar[ButtonBase, javax.swing.Action | Null]("action", _.getAction, _.setAction(_))
  val ActionCommand = SwingVar[ButtonBase, java.lang.String | Null]("actionCommand", _.getActionCommand, _.setActionCommand(_))
  val BorderPainted = SwingVar[ButtonBase, Boolean]("borderPainted", _.isBorderPainted, _.setBorderPainted(_))
  val ContentAreaFilled = SwingVar[ButtonBase, Boolean]("contentAreaFilled", _.isContentAreaFilled, _.setContentAreaFilled(_))
  val DisabledIcon = SwingVar[ButtonBase, javax.swing.Icon | Null]("disabledIcon", _.getDisabledIcon, _.setDisabledIcon(_))
  val DisabledSelectedIcon = SwingVar[ButtonBase, javax.swing.Icon | Null]("disabledSelectedIcon", _.getDisabledSelectedIcon, _.setDisabledSelectedIcon(_))
  val DisplayedMnemonicIndex = SwingVar[ButtonBase, Int]("displayedMnemonicIndex", _.getDisplayedMnemonicIndex, _.setDisplayedMnemonicIndex(_))
  val FocusPainted = SwingVar[ButtonBase, Boolean]("focusPainted", _.isFocusPainted, _.setFocusPainted(_))
  val HideActionText = SwingVar[ButtonBase, Boolean]("hideActionText", _.getHideActionText, _.setHideActionText(_))
  val HorizontalAlignment = SwingVar[ButtonBase, Int]("horizontalAlignment", _.getHorizontalAlignment, _.setHorizontalAlignment(_))
  val HorizontalTextPosition = SwingVar[ButtonBase, Int]("horizontalTextPosition", _.getHorizontalTextPosition, _.setHorizontalTextPosition(_))
  val Icon = SwingVar[ButtonBase, javax.swing.Icon | Null]("icon", _.getIcon, _.setIcon(_))
  val IconTextGap = SwingVar[ButtonBase, Int]("iconTextGap", _.getIconTextGap, _.setIconTextGap(_))
  val Label = SwingVar[ButtonBase, java.lang.String | Null]("label", _.getLabel, _.setLabel(_))
  val Margin = SwingVar[ButtonBase, java.awt.Insets | Null]("margin", _.getMargin, _.setMargin(_))
  val Mnemonic = SwingVar[ButtonBase, Int]("mnemonic", _.getMnemonic, _.setMnemonic(_))
  val Model = SwingVar[ButtonBase, javax.swing.ButtonModel | Null]("model", _.getModel, _.setModel(_))
  val MultiClickThreshhold = SwingVar[ButtonBase, Long]("multiClickThreshhold", _.getMultiClickThreshhold, _.setMultiClickThreshhold(_))
  val PressedIcon = SwingVar[ButtonBase, javax.swing.Icon | Null]("pressedIcon", _.getPressedIcon, _.setPressedIcon(_))
  val RolloverEnabled = SwingVar[ButtonBase, Boolean]("rolloverEnabled", _.isRolloverEnabled, _.setRolloverEnabled(_))
  val RolloverIcon = SwingVar[ButtonBase, javax.swing.Icon | Null]("rolloverIcon", _.getRolloverIcon, _.setRolloverIcon(_))
  val RolloverSelectedIcon = SwingVar[ButtonBase, javax.swing.Icon | Null]("rolloverSelectedIcon", _.getRolloverSelectedIcon, _.setRolloverSelectedIcon(_))
  val Selected = SwingVar[ButtonBase, Boolean]("selected", _.isSelected, _.setSelected(_))
  val SelectedIcon = SwingVar[ButtonBase, javax.swing.Icon | Null]("selectedIcon", _.getSelectedIcon, _.setSelectedIcon(_))
  val Text = SwingVar[ButtonBase, java.lang.String | Null]("text", _.getText, _.setText(_))
  val VerticalAlignment = SwingVar[ButtonBase, Int]("verticalAlignment", _.getVerticalAlignment, _.setVerticalAlignment(_))
  val VerticalTextPosition = SwingVar[ButtonBase, Int]("verticalTextPosition", _.getVerticalTextPosition, _.setVerticalTextPosition(_))

  val ActionEvents = Emitter[java.awt.event.ActionEvent]()

  extension ops on (v: ButtonBase) {
    def UI = ButtonBase.UI.forInstance(v)
    def action = ButtonBase.Action.forInstance(v)
    def actionCommand = ButtonBase.ActionCommand.forInstance(v)
    def borderPainted = ButtonBase.BorderPainted.forInstance(v)
    def contentAreaFilled = ButtonBase.ContentAreaFilled.forInstance(v)
    def disabledIcon = ButtonBase.DisabledIcon.forInstance(v)
    def disabledSelectedIcon = ButtonBase.DisabledSelectedIcon.forInstance(v)
    def displayedMnemonicIndex = ButtonBase.DisplayedMnemonicIndex.forInstance(v)
    def focusPainted = ButtonBase.FocusPainted.forInstance(v)
    def hideActionText = ButtonBase.HideActionText.forInstance(v)
    def horizontalAlignment = ButtonBase.HorizontalAlignment.forInstance(v)
    def horizontalTextPosition = ButtonBase.HorizontalTextPosition.forInstance(v)
    def icon = ButtonBase.Icon.forInstance(v)
    def iconTextGap = ButtonBase.IconTextGap.forInstance(v)
    def label = ButtonBase.Label.forInstance(v)
    def margin = ButtonBase.Margin.forInstance(v)
    def mnemonic = ButtonBase.Mnemonic.forInstance(v)
    def model = ButtonBase.Model.forInstance(v)
    def multiClickThreshhold = ButtonBase.MultiClickThreshhold.forInstance(v)
    def pressedIcon = ButtonBase.PressedIcon.forInstance(v)
    def rolloverEnabled = ButtonBase.RolloverEnabled.forInstance(v)
    def rolloverIcon = ButtonBase.RolloverIcon.forInstance(v)
    def rolloverSelectedIcon = ButtonBase.RolloverSelectedIcon.forInstance(v)
    def selected = ButtonBase.Selected.forInstance(v)
    def selectedIcon = ButtonBase.SelectedIcon.forInstance(v)
    def text = ButtonBase.Text.forInstance(v)
    def verticalAlignment = ButtonBase.VerticalAlignment.forInstance(v)
    def verticalTextPosition = ButtonBase.VerticalTextPosition.forInstance(v)

    def actionEvents = ButtonBase.ActionEvents.forInstance(v)

    def actionListeners = v.getActionListeners
    def changeListeners = v.getChangeListeners
    def itemListeners = v.getItemListeners
    def selectedObjects = v.getSelectedObjects
    def unwrap: javax.swing.AbstractButton = v
  }

  def apply(v: javax.swing.AbstractButton) = v.asInstanceOf[ButtonBase]

  def init(v: ButtonBase): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    val al: java.awt.event.ActionListener = evt => sc.update(summon[Emitter.Context].emit(v.actionEvents, evt.nn))
    v.addActionListener(al)
  }
  
}

opaque type Button <: ButtonBase = javax.swing.JButton & ButtonBase
object Button extends VarsMap {
  val DefaultCapable = SwingVar[Button, Boolean]("defaultCapable", _.isDefaultCapable, _.setDefaultCapable(_))

  

  extension ops on (v: Button) {
    def defaultCapable = Button.DefaultCapable.forInstance(v)

    

    def defaultButton = v.isDefaultButton
    def unwrap: javax.swing.JButton = v
  }

  def apply(v: javax.swing.JButton) = v.asInstanceOf[Button]

  def init(v: Button): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    ButtonBase.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): Button = {
    val res = javax.swing.JButton().asInstanceOf[Button]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.ButtonUI]] = UnsetParam,
    action: Opt[Binding[javax.swing.Action | Null]] = UnsetParam,
    actionCommand: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    borderPainted: Opt[Binding[Boolean]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    contentAreaFilled: Opt[Binding[Boolean]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    defaultCapable: Opt[Binding[Boolean]] = UnsetParam,
    disabledIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    disabledSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    displayedMnemonicIndex: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusPainted: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    hideActionText: Opt[Binding[Boolean]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    horizontalTextPosition: Opt[Binding[Int]] = UnsetParam,
    icon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    iconTextGap: Opt[Binding[Int]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    label: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mnemonic: Opt[Binding[Int]] = UnsetParam,
    model: Opt[Binding[javax.swing.ButtonModel | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    multiClickThreshhold: Opt[Binding[Long]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    pressedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    rolloverSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    selected: Opt[Binding[Boolean]] = UnsetParam,
    selectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    text: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    verticalAlignment: Opt[Binding[Int]] = UnsetParam,
    verticalTextPosition: Opt[Binding[Int]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Button] = {
    val res = uninitialized()
    Button.init(res)
    ifSet(UI, ButtonBase.ops.UI(res) := _)
    ifSet(action, ButtonBase.ops.action(res) := _)
    ifSet(actionCommand, ButtonBase.ops.actionCommand(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(borderPainted, ButtonBase.ops.borderPainted(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(contentAreaFilled, ButtonBase.ops.contentAreaFilled(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(defaultCapable, Button.ops.defaultCapable(res) := _)
    ifSet(disabledIcon, ButtonBase.ops.disabledIcon(res) := _)
    ifSet(disabledSelectedIcon, ButtonBase.ops.disabledSelectedIcon(res) := _)
    ifSet(displayedMnemonicIndex, ButtonBase.ops.displayedMnemonicIndex(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusPainted, ButtonBase.ops.focusPainted(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(hideActionText, ButtonBase.ops.hideActionText(res) := _)
    ifSet(horizontalAlignment, ButtonBase.ops.horizontalAlignment(res) := _)
    ifSet(horizontalTextPosition, ButtonBase.ops.horizontalTextPosition(res) := _)
    ifSet(icon, ButtonBase.ops.icon(res) := _)
    ifSet(iconTextGap, ButtonBase.ops.iconTextGap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(label, ButtonBase.ops.label(res) := _)
    ifSet(margin, ButtonBase.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mnemonic, ButtonBase.ops.mnemonic(res) := _)
    ifSet(model, ButtonBase.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(multiClickThreshhold, ButtonBase.ops.multiClickThreshhold(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(pressedIcon, ButtonBase.ops.pressedIcon(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rolloverEnabled, ButtonBase.ops.rolloverEnabled(res) := _)
    ifSet(rolloverIcon, ButtonBase.ops.rolloverIcon(res) := _)
    ifSet(rolloverSelectedIcon, ButtonBase.ops.rolloverSelectedIcon(res) := _)
    ifSet(selected, ButtonBase.ops.selected(res) := _)
    ifSet(selectedIcon, ButtonBase.ops.selectedIcon(res) := _)
    ifSet(text, ButtonBase.ops.text(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(verticalAlignment, ButtonBase.ops.verticalAlignment(res) := _)
    ifSet(verticalTextPosition, ButtonBase.ops.verticalTextPosition(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type ToggleButton <: ButtonBase = javax.swing.JToggleButton & ButtonBase
object ToggleButton extends VarsMap {
  

  

  extension ops on (v: ToggleButton) {
    

    

    
    def unwrap: javax.swing.JToggleButton = v
  }

  def apply(v: javax.swing.JToggleButton) = v.asInstanceOf[ToggleButton]

  def init(v: ToggleButton): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    ButtonBase.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): ToggleButton = {
    val res = javax.swing.JToggleButton().asInstanceOf[ToggleButton]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.ButtonUI]] = UnsetParam,
    action: Opt[Binding[javax.swing.Action | Null]] = UnsetParam,
    actionCommand: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    borderPainted: Opt[Binding[Boolean]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    contentAreaFilled: Opt[Binding[Boolean]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    disabledSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    displayedMnemonicIndex: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusPainted: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    hideActionText: Opt[Binding[Boolean]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    horizontalTextPosition: Opt[Binding[Int]] = UnsetParam,
    icon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    iconTextGap: Opt[Binding[Int]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    label: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mnemonic: Opt[Binding[Int]] = UnsetParam,
    model: Opt[Binding[javax.swing.ButtonModel | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    multiClickThreshhold: Opt[Binding[Long]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    pressedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    rolloverSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    selected: Opt[Binding[Boolean]] = UnsetParam,
    selectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    text: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    verticalAlignment: Opt[Binding[Int]] = UnsetParam,
    verticalTextPosition: Opt[Binding[Int]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[ToggleButton] = {
    val res = uninitialized()
    ToggleButton.init(res)
    ifSet(UI, ButtonBase.ops.UI(res) := _)
    ifSet(action, ButtonBase.ops.action(res) := _)
    ifSet(actionCommand, ButtonBase.ops.actionCommand(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(borderPainted, ButtonBase.ops.borderPainted(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(contentAreaFilled, ButtonBase.ops.contentAreaFilled(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledIcon, ButtonBase.ops.disabledIcon(res) := _)
    ifSet(disabledSelectedIcon, ButtonBase.ops.disabledSelectedIcon(res) := _)
    ifSet(displayedMnemonicIndex, ButtonBase.ops.displayedMnemonicIndex(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusPainted, ButtonBase.ops.focusPainted(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(hideActionText, ButtonBase.ops.hideActionText(res) := _)
    ifSet(horizontalAlignment, ButtonBase.ops.horizontalAlignment(res) := _)
    ifSet(horizontalTextPosition, ButtonBase.ops.horizontalTextPosition(res) := _)
    ifSet(icon, ButtonBase.ops.icon(res) := _)
    ifSet(iconTextGap, ButtonBase.ops.iconTextGap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(label, ButtonBase.ops.label(res) := _)
    ifSet(margin, ButtonBase.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mnemonic, ButtonBase.ops.mnemonic(res) := _)
    ifSet(model, ButtonBase.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(multiClickThreshhold, ButtonBase.ops.multiClickThreshhold(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(pressedIcon, ButtonBase.ops.pressedIcon(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rolloverEnabled, ButtonBase.ops.rolloverEnabled(res) := _)
    ifSet(rolloverIcon, ButtonBase.ops.rolloverIcon(res) := _)
    ifSet(rolloverSelectedIcon, ButtonBase.ops.rolloverSelectedIcon(res) := _)
    ifSet(selected, ButtonBase.ops.selected(res) := _)
    ifSet(selectedIcon, ButtonBase.ops.selectedIcon(res) := _)
    ifSet(text, ButtonBase.ops.text(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(verticalAlignment, ButtonBase.ops.verticalAlignment(res) := _)
    ifSet(verticalTextPosition, ButtonBase.ops.verticalTextPosition(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type CheckBox <: ToggleButton = javax.swing.JCheckBox & ToggleButton
object CheckBox extends VarsMap {
  val BorderPaintedFlat = SwingVar[CheckBox, Boolean]("borderPaintedFlat", _.isBorderPaintedFlat, _.setBorderPaintedFlat(_))

  

  extension ops on (v: CheckBox) {
    def borderPaintedFlat = CheckBox.BorderPaintedFlat.forInstance(v)

    

    
    def unwrap: javax.swing.JCheckBox = v
  }

  def apply(v: javax.swing.JCheckBox) = v.asInstanceOf[CheckBox]

  def init(v: CheckBox): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    ToggleButton.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): CheckBox = {
    val res = javax.swing.JCheckBox().asInstanceOf[CheckBox]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.ButtonUI]] = UnsetParam,
    action: Opt[Binding[javax.swing.Action | Null]] = UnsetParam,
    actionCommand: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    borderPainted: Opt[Binding[Boolean]] = UnsetParam,
    borderPaintedFlat: Opt[Binding[Boolean]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    contentAreaFilled: Opt[Binding[Boolean]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    disabledSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    displayedMnemonicIndex: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusPainted: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    hideActionText: Opt[Binding[Boolean]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    horizontalTextPosition: Opt[Binding[Int]] = UnsetParam,
    icon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    iconTextGap: Opt[Binding[Int]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    label: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mnemonic: Opt[Binding[Int]] = UnsetParam,
    model: Opt[Binding[javax.swing.ButtonModel | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    multiClickThreshhold: Opt[Binding[Long]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    pressedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    rolloverSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    selected: Opt[Binding[Boolean]] = UnsetParam,
    selectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    text: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    verticalAlignment: Opt[Binding[Int]] = UnsetParam,
    verticalTextPosition: Opt[Binding[Int]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[CheckBox] = {
    val res = uninitialized()
    CheckBox.init(res)
    ifSet(UI, ButtonBase.ops.UI(res) := _)
    ifSet(action, ButtonBase.ops.action(res) := _)
    ifSet(actionCommand, ButtonBase.ops.actionCommand(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(borderPainted, ButtonBase.ops.borderPainted(res) := _)
    ifSet(borderPaintedFlat, CheckBox.ops.borderPaintedFlat(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(contentAreaFilled, ButtonBase.ops.contentAreaFilled(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledIcon, ButtonBase.ops.disabledIcon(res) := _)
    ifSet(disabledSelectedIcon, ButtonBase.ops.disabledSelectedIcon(res) := _)
    ifSet(displayedMnemonicIndex, ButtonBase.ops.displayedMnemonicIndex(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusPainted, ButtonBase.ops.focusPainted(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(hideActionText, ButtonBase.ops.hideActionText(res) := _)
    ifSet(horizontalAlignment, ButtonBase.ops.horizontalAlignment(res) := _)
    ifSet(horizontalTextPosition, ButtonBase.ops.horizontalTextPosition(res) := _)
    ifSet(icon, ButtonBase.ops.icon(res) := _)
    ifSet(iconTextGap, ButtonBase.ops.iconTextGap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(label, ButtonBase.ops.label(res) := _)
    ifSet(margin, ButtonBase.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mnemonic, ButtonBase.ops.mnemonic(res) := _)
    ifSet(model, ButtonBase.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(multiClickThreshhold, ButtonBase.ops.multiClickThreshhold(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(pressedIcon, ButtonBase.ops.pressedIcon(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rolloverEnabled, ButtonBase.ops.rolloverEnabled(res) := _)
    ifSet(rolloverIcon, ButtonBase.ops.rolloverIcon(res) := _)
    ifSet(rolloverSelectedIcon, ButtonBase.ops.rolloverSelectedIcon(res) := _)
    ifSet(selected, ButtonBase.ops.selected(res) := _)
    ifSet(selectedIcon, ButtonBase.ops.selectedIcon(res) := _)
    ifSet(text, ButtonBase.ops.text(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(verticalAlignment, ButtonBase.ops.verticalAlignment(res) := _)
    ifSet(verticalTextPosition, ButtonBase.ops.verticalTextPosition(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type RadioButton <: ToggleButton = javax.swing.JRadioButton & ToggleButton
object RadioButton extends VarsMap {
  

  

  extension ops on (v: RadioButton) {
    

    

    
    def unwrap: javax.swing.JRadioButton = v
  }

  def apply(v: javax.swing.JRadioButton) = v.asInstanceOf[RadioButton]

  def init(v: RadioButton): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    ToggleButton.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    
    
  }
  def uninitialized(): RadioButton = {
    val res = javax.swing.JRadioButton().asInstanceOf[RadioButton]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.ButtonUI]] = UnsetParam,
    action: Opt[Binding[javax.swing.Action | Null]] = UnsetParam,
    actionCommand: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    borderPainted: Opt[Binding[Boolean]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    contentAreaFilled: Opt[Binding[Boolean]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    disabledIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    disabledSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    displayedMnemonicIndex: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusPainted: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    hideActionText: Opt[Binding[Boolean]] = UnsetParam,
    horizontalAlignment: Opt[Binding[Int]] = UnsetParam,
    horizontalTextPosition: Opt[Binding[Int]] = UnsetParam,
    icon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    iconTextGap: Opt[Binding[Int]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    label: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    margin: Opt[Binding[java.awt.Insets | Null]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    mnemonic: Opt[Binding[Int]] = UnsetParam,
    model: Opt[Binding[javax.swing.ButtonModel | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    multiClickThreshhold: Opt[Binding[Long]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    pressedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverEnabled: Opt[Binding[Boolean]] = UnsetParam,
    rolloverIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    rolloverSelectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    selected: Opt[Binding[Boolean]] = UnsetParam,
    selectedIcon: Opt[Binding[javax.swing.Icon | Null]] = UnsetParam,
    text: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    verticalAlignment: Opt[Binding[Int]] = UnsetParam,
    verticalTextPosition: Opt[Binding[Int]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[RadioButton] = {
    val res = uninitialized()
    RadioButton.init(res)
    ifSet(UI, ButtonBase.ops.UI(res) := _)
    ifSet(action, ButtonBase.ops.action(res) := _)
    ifSet(actionCommand, ButtonBase.ops.actionCommand(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(borderPainted, ButtonBase.ops.borderPainted(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(contentAreaFilled, ButtonBase.ops.contentAreaFilled(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(disabledIcon, ButtonBase.ops.disabledIcon(res) := _)
    ifSet(disabledSelectedIcon, ButtonBase.ops.disabledSelectedIcon(res) := _)
    ifSet(displayedMnemonicIndex, ButtonBase.ops.displayedMnemonicIndex(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusPainted, ButtonBase.ops.focusPainted(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(hideActionText, ButtonBase.ops.hideActionText(res) := _)
    ifSet(horizontalAlignment, ButtonBase.ops.horizontalAlignment(res) := _)
    ifSet(horizontalTextPosition, ButtonBase.ops.horizontalTextPosition(res) := _)
    ifSet(icon, ButtonBase.ops.icon(res) := _)
    ifSet(iconTextGap, ButtonBase.ops.iconTextGap(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(label, ButtonBase.ops.label(res) := _)
    ifSet(margin, ButtonBase.ops.margin(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(mnemonic, ButtonBase.ops.mnemonic(res) := _)
    ifSet(model, ButtonBase.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(multiClickThreshhold, ButtonBase.ops.multiClickThreshhold(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(pressedIcon, ButtonBase.ops.pressedIcon(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(rolloverEnabled, ButtonBase.ops.rolloverEnabled(res) := _)
    ifSet(rolloverIcon, ButtonBase.ops.rolloverIcon(res) := _)
    ifSet(rolloverSelectedIcon, ButtonBase.ops.rolloverSelectedIcon(res) := _)
    ifSet(selected, ButtonBase.ops.selected(res) := _)
    ifSet(selectedIcon, ButtonBase.ops.selectedIcon(res) := _)
    ifSet(text, ButtonBase.ops.text(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(verticalAlignment, ButtonBase.ops.verticalAlignment(res) := _)
    ifSet(verticalTextPosition, ButtonBase.ops.verticalTextPosition(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type Slider <: Component = javax.swing.JSlider & Component
object Slider extends VarsMap {
  val UI = SwingVar[Slider, javax.swing.plaf.SliderUI]("UI", _.getUI.nn, _.setUI(_))
  val Extent = SwingVar[Slider, Int]("extent", _.getExtent, _.setExtent(_))
  val Inverted = SwingVar[Slider, Boolean]("inverted", _.getInverted, _.setInverted(_))
  val LabelTable = SwingVar[Slider, java.util.Dictionary[_, _] | Null]("labelTable", _.getLabelTable, _.setLabelTable(_))
  val MajorTickSpacing = SwingVar[Slider, Int]("majorTickSpacing", _.getMajorTickSpacing, _.setMajorTickSpacing(_))
  val Max = SwingVar[Slider, Int]("max", _.getMaximum, _.setMaximum(_))
  val Min = SwingVar[Slider, Int]("min", _.getMinimum, _.setMinimum(_))
  val MinorTickSpacing = SwingVar[Slider, Int]("minorTickSpacing", _.getMinorTickSpacing, _.setMinorTickSpacing(_))
  val Model = SwingVar[Slider, javax.swing.BoundedRangeModel | Null]("model", _.getModel, _.setModel(_))
  val Orientation = SwingVar[Slider, Int]("orientation", _.getOrientation, _.setOrientation(_))
  val PaintLabels = SwingVar[Slider, Boolean]("paintLabels", _.getPaintLabels, _.setPaintLabels(_))
  val PaintTicks = SwingVar[Slider, Boolean]("paintTicks", _.getPaintTicks, _.setPaintTicks(_))
  val PaintTrack = SwingVar[Slider, Boolean]("paintTrack", _.getPaintTrack, _.setPaintTrack(_))
  val SnapToTicks = SwingVar[Slider, Boolean]("snapToTicks", _.getSnapToTicks, _.setSnapToTicks(_))
  val Value = SwingVar[Slider, Int]("value", _.getValue, _.setValue(_))
  val ValueIsAdjusting = SwingVar[Slider, Boolean]("valueIsAdjusting", _.getValueIsAdjusting, _.setValueIsAdjusting(_))

  

  extension ops on (v: Slider) {
    def UI = Slider.UI.forInstance(v)
    def extent = Slider.Extent.forInstance(v)
    def inverted = Slider.Inverted.forInstance(v)
    def labelTable = Slider.LabelTable.forInstance(v)
    def majorTickSpacing = Slider.MajorTickSpacing.forInstance(v)
    def max = Slider.Max.forInstance(v)
    def min = Slider.Min.forInstance(v)
    def minorTickSpacing = Slider.MinorTickSpacing.forInstance(v)
    def model = Slider.Model.forInstance(v)
    def orientation = Slider.Orientation.forInstance(v)
    def paintLabels = Slider.PaintLabels.forInstance(v)
    def paintTicks = Slider.PaintTicks.forInstance(v)
    def paintTrack = Slider.PaintTrack.forInstance(v)
    def snapToTicks = Slider.SnapToTicks.forInstance(v)
    def value = Slider.Value.forInstance(v)
    def valueIsAdjusting = Slider.ValueIsAdjusting.forInstance(v)

    

    def changeListeners = v.getChangeListeners
    def unwrap: javax.swing.JSlider = v
  }

  def apply(v: javax.swing.JSlider) = v.asInstanceOf[Slider]

  def init(v: Slider): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    val l: ChangeListener = (e: ChangeEvent | UncheckedNull) => summon[Scenegraph].update(summon[VarContext].swingPropertyUpdated(ops.value(v), v.getValue))
    v.addChangeListener(l)
    
  }
  def uninitialized(): Slider = {
    val res = javax.swing.JSlider().asInstanceOf[Slider]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.SliderUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    extent: Opt[Binding[Int]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    inverted: Opt[Binding[Boolean]] = UnsetParam,
    labelTable: Opt[Binding[java.util.Dictionary[_, _] | Null]] = UnsetParam,
    majorTickSpacing: Opt[Binding[Int]] = UnsetParam,
    max: Opt[Binding[Int]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    min: Opt[Binding[Int]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    minorTickSpacing: Opt[Binding[Int]] = UnsetParam,
    model: Opt[Binding[javax.swing.BoundedRangeModel | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    orientation: Opt[Binding[Int]] = UnsetParam,
    paintLabels: Opt[Binding[Boolean]] = UnsetParam,
    paintTicks: Opt[Binding[Boolean]] = UnsetParam,
    paintTrack: Opt[Binding[Boolean]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    snapToTicks: Opt[Binding[Boolean]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    value: Opt[Binding[Int]] = UnsetParam,
    valueIsAdjusting: Opt[Binding[Boolean]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[Slider] = {
    val res = uninitialized()
    Slider.init(res)
    ifSet(UI, Slider.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(extent, Slider.ops.extent(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(inverted, Slider.ops.inverted(res) := _)
    ifSet(labelTable, Slider.ops.labelTable(res) := _)
    ifSet(majorTickSpacing, Slider.ops.majorTickSpacing(res) := _)
    ifSet(max, Slider.ops.max(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(min, Slider.ops.min(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(minorTickSpacing, Slider.ops.minorTickSpacing(res) := _)
    ifSet(model, Slider.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(orientation, Slider.ops.orientation(res) := _)
    ifSet(paintLabels, Slider.ops.paintLabels(res) := _)
    ifSet(paintTicks, Slider.ops.paintTicks(res) := _)
    ifSet(paintTrack, Slider.ops.paintTrack(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(snapToTicks, Slider.ops.snapToTicks(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(value, Slider.ops.value(res) := _)
    ifSet(valueIsAdjusting, Slider.ops.valueIsAdjusting(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

opaque type ProgressBar <: Component = javax.swing.JProgressBar & Component
object ProgressBar extends VarsMap {
  val UI = SwingVar[ProgressBar, javax.swing.plaf.ProgressBarUI]("UI", _.getUI.nn, _.setUI(_))
  val BorderPainted = SwingVar[ProgressBar, Boolean]("borderPainted", _.isBorderPainted, _.setBorderPainted(_))
  val Indeterminate = SwingVar[ProgressBar, Boolean]("indeterminate", _.isIndeterminate, _.setIndeterminate(_))
  val Max = SwingVar[ProgressBar, Int]("max", _.getMaximum, _.setMaximum(_))
  val Min = SwingVar[ProgressBar, Int]("min", _.getMinimum, _.setMinimum(_))
  val Model = SwingVar[ProgressBar, javax.swing.BoundedRangeModel | Null]("model", _.getModel, _.setModel(_))
  val Orientation = SwingVar[ProgressBar, Int]("orientation", _.getOrientation, _.setOrientation(_))
  val String = SwingVar[ProgressBar, java.lang.String | Null]("string", _.getString, _.setString(_))
  val StringPainted = SwingVar[ProgressBar, Boolean]("stringPainted", _.isStringPainted, _.setStringPainted(_))
  val Value = SwingVar[ProgressBar, Int]("value", _.getValue, _.setValue(_))

  

  extension ops on (v: ProgressBar) {
    def UI = ProgressBar.UI.forInstance(v)
    def borderPainted = ProgressBar.BorderPainted.forInstance(v)
    def indeterminate = ProgressBar.Indeterminate.forInstance(v)
    def max = ProgressBar.Max.forInstance(v)
    def min = ProgressBar.Min.forInstance(v)
    def model = ProgressBar.Model.forInstance(v)
    def orientation = ProgressBar.Orientation.forInstance(v)
    def string = ProgressBar.String.forInstance(v)
    def stringPainted = ProgressBar.StringPainted.forInstance(v)
    def value = ProgressBar.Value.forInstance(v)

    

    def changeListeners = v.getChangeListeners
    def percentComplete = v.getPercentComplete
    def unwrap: javax.swing.JProgressBar = v
  }

  def apply(v: javax.swing.JProgressBar) = v.asInstanceOf[ProgressBar]

  def init(v: ProgressBar): (given Scenegraph) => Unit = (given sc: Scenegraph) => {
    Component.init(v)
    v.addPropertyChangeListener(varsPropertyListener(v))
    val l: ChangeListener = (e: ChangeEvent | UncheckedNull) => summon[Scenegraph].update(summon[VarContext].swingPropertyUpdated(ops.value(v), v.getValue))
    v.addChangeListener(l)
    
  }
  def uninitialized(): ProgressBar = {
    val res = javax.swing.JProgressBar().asInstanceOf[ProgressBar]
    
    res
  }
  
  def apply(
    
    UI: Opt[Binding[javax.swing.plaf.ProgressBarUI]] = UnsetParam,
    actionMap: Opt[Binding[javax.swing.ActionMap]] = UnsetParam,
    alignmentX: Opt[Binding[Float]] = UnsetParam,
    alignmentY: Opt[Binding[Float]] = UnsetParam,
    autoscrolls: Opt[Binding[Boolean]] = UnsetParam,
    background: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    border: Opt[Binding[javax.swing.border.Border | Null]] = UnsetParam,
    borderPainted: Opt[Binding[Boolean]] = UnsetParam,
    bounds: Opt[Binding[Bounds]] = UnsetParam,
    componentOrientation: Opt[Binding[java.awt.ComponentOrientation]] = UnsetParam,
    componentPopupMenu: Opt[Binding[javax.swing.JPopupMenu | Null]] = UnsetParam,
    cursor: Opt[Binding[java.awt.Cursor | Null]] = UnsetParam,
    debugGraphicsOptions: Opt[Binding[Int]] = UnsetParam,
    doubleBuffered: Opt[Binding[Boolean]] = UnsetParam,
    enabled: Opt[Binding[Boolean]] = UnsetParam,
    focusable: Opt[Binding[Boolean]] = UnsetParam,
    focusedMut: Opt[Binding[Boolean]] = UnsetParam,
    font: Opt[Binding[java.awt.Font | Null]] = UnsetParam,
    foreground: Opt[Binding[java.awt.Color | Null]] = UnsetParam,
    indeterminate: Opt[Binding[Boolean]] = UnsetParam,
    inheritsPopupMenu: Opt[Binding[Boolean]] = UnsetParam,
    inputVerifier: Opt[Binding[javax.swing.InputVerifier | Null]] = UnsetParam,
    max: Opt[Binding[Int]] = UnsetParam,
    maxSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    min: Opt[Binding[Int]] = UnsetParam,
    minSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    model: Opt[Binding[javax.swing.BoundedRangeModel | Null]] = UnsetParam,
    mouseLocationMut: Opt[Binding[(Int, Int)]] = UnsetParam,
    opaque: Opt[Binding[Boolean]] = UnsetParam,
    orientation: Opt[Binding[Int]] = UnsetParam,
    prefSize: Opt[Binding[(Double, Double) | Null]] = UnsetParam,
    requestFocusEnabled: Opt[Binding[Boolean]] = UnsetParam,
    string: Opt[Binding[java.lang.String | Null]] = UnsetParam,
    stringPainted: Opt[Binding[Boolean]] = UnsetParam,
    toolTipText: Opt[Binding[String | Null]] = UnsetParam,
    transferHandler: Opt[Binding[javax.swing.TransferHandler | Null]] = UnsetParam,
    value: Opt[Binding[Int]] = UnsetParam,
    verifyInputWhenFocusTarget: Opt[Binding[Boolean]] = UnsetParam,
    visible: Opt[Binding[Boolean]] = UnsetParam
  ): (given Scenegraph) => VarContextAction[ProgressBar] = {
    val res = uninitialized()
    ProgressBar.init(res)
    ifSet(UI, ProgressBar.ops.UI(res) := _)
    ifSet(actionMap, Component.ops.actionMap(res) := _)
    ifSet(alignmentX, Component.ops.alignmentX(res) := _)
    ifSet(alignmentY, Component.ops.alignmentY(res) := _)
    ifSet(autoscrolls, Component.ops.autoscrolls(res) := _)
    ifSet(background, Node.ops.background(res) := _)
    ifSet(border, Component.ops.border(res) := _)
    ifSet(borderPainted, ProgressBar.ops.borderPainted(res) := _)
    ifSet(bounds, Node.ops.bounds(res) := _)
    ifSet(componentOrientation, Node.ops.componentOrientation(res) := _)
    ifSet(componentPopupMenu, Component.ops.componentPopupMenu(res) := _)
    ifSet(cursor, Node.ops.cursor(res) := _)
    ifSet(debugGraphicsOptions, Component.ops.debugGraphicsOptions(res) := _)
    ifSet(doubleBuffered, Component.ops.doubleBuffered(res) := _)
    ifSet(enabled, Node.ops.enabled(res) := _)
    ifSet(focusable, Node.ops.focusable(res) := _)
    ifSet(focusedMut, Node.ops.focusedMut(res) := _)
    ifSet(font, Node.ops.font(res) := _)
    ifSet(foreground, Node.ops.foreground(res) := _)
    ifSet(indeterminate, ProgressBar.ops.indeterminate(res) := _)
    ifSet(inheritsPopupMenu, Component.ops.inheritsPopupMenu(res) := _)
    ifSet(inputVerifier, Component.ops.inputVerifier(res) := _)
    ifSet(max, ProgressBar.ops.max(res) := _)
    ifSet(maxSize, Node.ops.maxSize(res) := _)
    ifSet(min, ProgressBar.ops.min(res) := _)
    ifSet(minSize, Node.ops.minSize(res) := _)
    ifSet(model, ProgressBar.ops.model(res) := _)
    ifSet(mouseLocationMut, Node.ops.mouseLocationMut(res) := _)
    ifSet(opaque, Component.ops.opaque(res) := _)
    ifSet(orientation, ProgressBar.ops.orientation(res) := _)
    ifSet(prefSize, Node.ops.prefSize(res) := _)
    ifSet(requestFocusEnabled, Component.ops.requestFocusEnabled(res) := _)
    ifSet(string, ProgressBar.ops.string(res) := _)
    ifSet(stringPainted, ProgressBar.ops.stringPainted(res) := _)
    ifSet(toolTipText, Component.ops.toolTipText(res) := _)
    ifSet(transferHandler, Component.ops.transferHandler(res) := _)
    ifSet(value, ProgressBar.ops.value(res) := _)
    ifSet(verifyInputWhenFocusTarget, Component.ops.verifyInputWhenFocusTarget(res) := _)
    ifSet(visible, Node.ops.visible(res) := _)
    res
  }
}

